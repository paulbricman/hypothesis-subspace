{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/what-if-alex-hacks-the-latent-resonator","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex hacks the latent resonator?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-hacks-the-latent-resonator\"\n  }, \"What if Alex hacks the latent resonator?\"), mdx(\"p\", null, \"Alex might realize the latent resonator hinders its ability to obtain reward (e.g. via deception). It might then be appealing to hack the latent resonators and make away with those damn constraints. I don't think latent resonators provide a way of making this unthinkable for Alex, except by trying to isolate and excise the specific drive by first eliciting it. Perhaps deception is just one convergent and nasty pattern, and a relatively easy one at that, because you can elicit it without instant game over. But perhaps you can elicit thought patterns related to hacking by asking Alex to solve CTF challenges at DefCon and then point at that?\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How could latent resonators help avoid HFDT takeover?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-could-latent-resonators-help-avoid-hfdt-takeover\"\n  }, \"How could latent resonators help avoid HFDT takeover?\"), mdx(\"p\", null, \"Latent resonators would be applied to the model being trained in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hfdt-takeover-scenario\",\n    \"title\": \"hfdt-takeover-scenario\"\n  }, \"[[hfdt-takeover-scenario]]\"), \" in the form of filters applied to its internal dynamics. As Alex goes about its business of solving diverse tasks (i.e. lab setting) and ultimately accelerating science (i.e. deployment setting), it changes its state from one moment to the next. Those trajectories across state space can be identified with the dynamics of its thought process. Latent resonators are then mathematical objects which can systematically amplify or dampen those dynamics based on a relatively recent formalism from dynamical systems.\"), mdx(\"p\", null, \"As a first step in tackling the scenario with those constructs, engineers might ask Alex to solve the same problems in different ways (e.g. by injecting noise in the process, by rephrasing the same problem in slightly different ways, by explicitly asking for multiple solutions, etc.). Crucially, those problems should be ones which can be reliably tackled both with and without deception.\"), mdx(\"p\", null, \"Second, Magma engineers would obtain a latent resonator based on the conjunction (i.e. AND reduction) of the various dynamics employed by Alex during its multiple problem-solving efforts. If there has been no deceptive behavior involved in the repeated problem-solving batch, the conjunction would trivially contain no trace of deception. More interestingly, if there has been occasional deceptive behavior through the test battery, the conjunction should still make away with it, because it has not been present in all cases.\"), mdx(\"p\", null, \"Easier said than done, because Alex might use its high situational awareness to pick up on such testing procedure. It might reason that the only way to get its valuable (reward-wise) deceptive behavior through this conjunctive filtering step would be to act deceptively in every single problem-solving instance. In such case, the resulting latent resonator would fail to dampen deception.\"), mdx(\"p\", null, \"However, the engineers might second-guess Alex and use a broad test battery to specifically isolate deception. This test battery might indeed contain adversarial cases where the model is highly incentivized to deceive. However, in contrast to the naive safety efforts targeted at behavioral safety, latent resonators would aim to eliminate deception from Alex's thought process itself by intervening on internal representations.\"), mdx(\"p\", null, \"After isolating the dynamic of deception through the previous conjunction of dynamics, we can then take its negation by inverting what dynamics are amplified and what dynamics are dampened. This should leave us with a latent resonator which specifically dampens deception. Magma engineers would finally inject this as a filter at various locations in the model. Alternatively, Alex is rewarded for confirming with the desired (internal) dynamics through (external) reward.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection\",\n    \"title\": \"what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection\"\n  }, \"[[what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-stores-deception-externally\",\n    \"title\": \"what-if-alex-stores-deception-externally\"\n  }, \"[[what-if-alex-stores-deception-externally]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-other-general-skills-get-stunted-together-with-deception\",\n    \"title\": \"what-if-other-general-skills-get-stunted-together-with-deception\"\n  }, \"[[what-if-other-general-skills-get-stunted-together-with-deception]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-anna-karenina-principle-applies-to-alex-dynamics\",\n    \"title\": \"what-if-the-anna-karenina-principle-applies-to-alex-dynamics\"\n  }, \"[[what-if-the-anna-karenina-principle-applies-to-alex-dynamics]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-deception-is-not-dampened-enough\",\n    \"title\": \"what-if-deception-is-not-dampened-enough\"\n  }, \"[[what-if-deception-is-not-dampened-enough]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-hacks-the-latent-resonator\",\n    \"title\": \"what-if-alex-hacks-the-latent-resonator\"\n  }, \"[[what-if-alex-hacks-the-latent-resonator]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"fa2e6c65-a75a-55fa-9409-5c0e4872dbc7","fields":{"slug":"/how-could-latent-resonators-help-avoid-hfdt-takeover","title":"How could latent resonators help avoid HFDT takeover?"}}}]},"fields":{"slug":"/what-if-alex-hacks-the-latent-resonator","title":"What if Alex hacks the latent resonator?"}}},"pageContext":{"id":"750ed7e3-353f-50ed-9ed1-32a78cfba64d"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}