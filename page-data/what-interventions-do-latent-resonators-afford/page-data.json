{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/what-interventions-do-latent-resonators-afford","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What interventions do latent resonators afford?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-interventions-do-latent-resonators-afford\"\n  }, \"What interventions do latent resonators afford?\"), mdx(\"p\", null, \"Intervention atoms:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"isolate\"), \": Take the conjuction of multiple exemplified patterns in an attempt to isolate the signature of a common dynamic.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"merge\"), \": Take the disjunction of multiple isolated dynamics.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"amplify\"), \": Inject a filter which amplifies one or more given dynamics relative to the others.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"suppress\"), \": Inject a filter which dampens one or more given dynamics relative to the others.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"verify\"), \": Detect whether an ML model has previously internalized one or more given dynamics.\")), mdx(\"p\", null, \"Interventions:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"isolate\"), \" + \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"amplify\"), \": Nudge the model towards making use of a whitelisted dynamic.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"isolate\"), \" + \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"merge\"), \" + \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"amplify\"), \": Nudge the model towards making use of multiple whitelisted dynamics.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"isolate\"), \" + \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"suppress\"), \": Nudge the model away from making use of a blacklisted dynamic.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"isolate\"), \" + \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"merge\"), \" + \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"suppress\"), \": Nudge the model away from making use of multiple blacklisted dynamics.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"isolate\"), \" + \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"verify\"), \": Check whether an unboxed model is fluent in one or more blacklisted dynamics by boxing it, training and isolating the target dynamic(s), and estimating the amount of recycled representational resources.\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Latent Resonators\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"latent-resonators\"\n  }, \"Latent Resonators\"), mdx(\"p\", null, \"In the context of autoregressive models, prompts are often seen as \\\"programs\\\" which specify various behaviors for the model to \\\"run\\\" next. What if we framed prompts as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"resonance chambers\"), \" of different shapes and sizes which amplify certain dynamics while dampening others? The goal would then be to devise such constructs which reliably make away with misaligned spectral components, and apply them directly to latent activations. One promising way of doing this relies on a new formalism from dynamical systems which defines an entire Boolean logic of dynamics. By taking the conjunction of whitelisted dynamics and negating blacklisted ones, we can craft and inject filters in ML models while only incurring minimal compute overhead. The layer depth of the injection site might also offer a slider between influencing the way a model \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"perceives\"), \" the world and the way it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"acts\"), \" in given circumstances.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-latent-resonators-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-latent-resonators-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-latent-resonators-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-could-latent-resonators-help-avoid-hfdt-takeover\",\n    \"title\": \"how-could-latent-resonators-help-avoid-hfdt-takeover\"\n  }, \"[[how-could-latent-resonators-help-avoid-hfdt-takeover]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-interventions-do-latent-resonators-afford\",\n    \"title\": \"what-interventions-do-latent-resonators-afford\"\n  }, \"[[what-interventions-do-latent-resonators-afford]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"22da8d58-963c-5f3c-abaa-d6c84cbe1faa","fields":{"slug":"/latent-resonators","title":"Latent Resonators"}}}]},"fields":{"slug":"/what-interventions-do-latent-resonators-afford","title":"What interventions do latent resonators afford?"}}},"pageContext":{"id":"7a6f2a51-512b-584b-85c5-b15bd4c7d49f"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}