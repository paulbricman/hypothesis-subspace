{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/representational-alignment","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Representational Alignment\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"representational-alignment\"\n  }, \"Representational Alignment\"), mdx(\"p\", null, \"As a step in aligning AGI to human intent, we might want to first align the latent representations of ML models with the latent representations of humans. This would mean bypassing human language and behavior entirely, and incentivizing the ML model to make use of representations which can accurately be translated to and from neural activity. This should generally ensure that human representations and human representations alone are employed by the ML model in its internal thought process. Finally, as a slider of capability, we might gradually shift towards relaxing the translatability constrain by applying it to model \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"shards\"), \" only, rather than holistically. This is analogous to a team of developers working on a codebase, where each one is only responsible for a chunk of it. The codebase is still represented in human brains, but no single brain represents it.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-representational-alignment-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-does-representational-alignment-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-does-representational-alignment-relate-to-concrete-challenges-in-alignment]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How does representational alignment relate to concrete challenges in alignment?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-does-representational-alignment-relate-to-concrete-challenges-in-alignment\"\n  }, \"How does representational alignment relate to concrete challenges in alignment?\"), mdx(\"p\", null, \"Similar to abstraction inductors, physicalist fluency provides a different path to promoting shared abstractions between human and AI, which can then be made use of as part of the objective function. However, it has the added benefit of providing an arbitrary limit on the richness of internal representations in relation to those of one human. In this, it addresses inner alignment.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"a2fb53b5-0b6d-5c1b-83c3-efba65ce2e9f","fields":{"slug":"/how-does-representational-alignment-relate-to-concrete-challenges-in-alignment","title":"How does representational alignment relate to concrete challenges in alignment?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if training humans is not feasible?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-training-humans-is-not-feasible\"\n  }, \"What if training humans is not feasible?\"), mdx(\"p\", null, \"Perhaps the internal representations used by the ML model are so alien that trying to teach humans this foreign language would fail spectacularly. The main source of replies to this family of counterarguments might come from the fact that the ML model itself is incentivized to use its representational resources efficiently, striking a balance between \\\"speaker economy\\\" and \\\"message clarity\\\". We have reasons to believe the ML model's internal language and human languages might exhibit convergent evolution due to the perks of resource efficiency.\"), mdx(\"p\", null, \"Still, despite the ML model coming up with its own internal \\\"mathematical\\\" instead of \\\"written multiple-paragraph\\\", for various parts of its conceptual framework, it might still be too advanced. Imagine having to learn Chinese in one-week tops (as an attempt to artificially constrain capabilities and at the same time boost the difficulty of a human-made problem into superhuman territory). Alternatively, imagine teaching non-human primates to write coherent English by pressing on a keyboard. Unlikely to happen to a reliable extent.\"), mdx(\"p\", null, \"This feels like the opposite side of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/what-if-the-bottleneck-layer-is-too-constraining\",\n    \"title\": \"what-if-the-bottleneck-layer-is-too-constraining\"\n  }, \"[[what-if-the-bottleneck-layer-is-too-constraining]]\"), \" struggle. It might be interesting to add additional constraints on the internal representation inspired by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \" to help bring the two modes of thought closer, in order to avoid this clash in sophistication. This might refer to both making the model's representations easier to perceive (the realm of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bridger-languages\",\n    \"title\": \"bridger-languages\"\n  }, \"[[bridger-languages]]\"), \"), but also closer to the human thing (the realm of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \").\"), mdx(\"p\", null, \"Another approach would be to split the task of acquiring the ML model's language into subtask through a chain of bridger languages. The whole chain would be learned by the ML model, where each element of the chain would be constrained to be within a threshold of divergence (e.g. KL divergence) with its neighboring languages. Additionally, the one end of the chain would have to be a human language. Following this, people would gradually learn to bridge the representational gap. Potentially, new generations might gradually move across the gap, each internalizing a more alien version of the language, which would come to feel natural.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"cd6362e8-2d2d-5819-a8da-e5f1fa4f0879","fields":{"slug":"/what-if-training-humans-is-not-feasible","title":"What if training humans is not feasible?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Representational Tethers\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"representational-tethers\"\n  }, \"Representational Tethers\"), mdx(\"p\", null, \"Representational tethers are a merger of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bridger-languages\",\n    \"title\": \"bridger-languages\"\n  }, \"[[bridger-languages]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \". They are means of relating the internal representations of ML models with internal representations employed by humans. One part of this process is incentivizing the artificial representations to be cross-compatible with humans ones (the legacy of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \"). Another aspect is enabling people to perceive and understand said artificial representations by making them more legible and cognitively ergonomic for humans (the legacy of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bridger-languages\",\n    \"title\": \"bridger-languages\"\n  }, \"[[bridger-languages]]\"), \"). The two previous frames complement each other: it's easier to understand a language containing concepts you're familiar with than a more alien one (a shortcoming of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/differentiable-cosmogonies\",\n    \"title\": \"differentiable-cosmogonies\"\n  }, \"[[differentiable-cosmogonies]]\"), \"), and it's easier to keep a representation within reach if you make sure it's consciously accessible at the other end. Representational tethers are meant to further alignment by improving human oversight or automated versions thereof.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"d73f0863-33c4-5913-8b6c-e2f1cc555436","fields":{"slug":"/representational-tethers","title":"Representational Tethers"}}}]},"fields":{"slug":"/representational-alignment","title":"Representational Alignment"}}},"pageContext":{"id":"175de8ae-a21d-56db-8fd2-27699bd740d6"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}