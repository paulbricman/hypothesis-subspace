{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/representational-tethers","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Representational Tethers\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"representational-tethers\"\n  }, \"Representational Tethers\"), mdx(\"p\", null, \"Representational tethers are a merger of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bridger-languages\",\n    \"title\": \"bridger-languages\"\n  }, \"[[bridger-languages]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \". They are means of relating the internal representations of ML models with internal representations employed by humans. One part of this process is incentivizing the artificial representations to be cross-compatible with humans ones (the legacy of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \"). Another aspect is enabling people to perceive and understand said artificial representations by making them more legible and cognitively ergonomic for humans (the legacy of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bridger-languages\",\n    \"title\": \"bridger-languages\"\n  }, \"[[bridger-languages]]\"), \"). The two previous frames complement each other: it's easier to understand a language containing concepts you're familiar with than a more alien one (a shortcoming of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/differentiable-cosmogonies\",\n    \"title\": \"differentiable-cosmogonies\"\n  }, \"[[differentiable-cosmogonies]]\"), \"), and it's easier to keep a representation within reach if you make sure it's consciously accessible at the other end. Representational tethers are meant to further alignment by improving human oversight or automated versions thereof.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Bridger Languages\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bridger-languages\"\n  }, \"Bridger Languages\"), mdx(\"p\", null, \"Interpretability tools generally assume no prior training on the part of humans when dissecting a model's internal representations. What if we allowed for explicit human training in a bridging language which is directly employed by a model? This might require us to apply principles of cognitive ergonomics to a bottleneck layer (e.g. sparsity, local structure, discreteness, Gestalt-aware symbols), so that humans could become fluent in the bridging language. A nested lattice of quantized \\\"logograms\\\" might be fitting, and young children might be particularly fit for the role of bridging the two different modes of thought. Pairs of artifacts in familiar modalities (e.g. text, images, videos) and associated translations could form the basis of the learning process, together with any discovered syntax of the emerging language.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-bridger-languages-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-bridger-languages-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-bridger-languages-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-the-best-case-scenario-for-bridger-languages-sound-like\",\n    \"title\": \"how-does-the-best-case-scenario-for-bridger-languages-sound-like\"\n  }, \"[[how-does-the-best-case-scenario-for-bridger-languages-sound-like]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"3ab0b7b0-6877-526c-b13a-7f15ce7f5792","fields":{"slug":"/bridger-languages","title":"Bridger Languages"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Representational Alignment\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"representational-alignment\"\n  }, \"Representational Alignment\"), mdx(\"p\", null, \"As a step in aligning AGI to human intent, we might want to first align the latent representations of ML models with the latent representations of humans. This would mean bypassing human language and behavior entirely, and incentivizing the ML model to make use of representations which can accurately be translated to and from neural activity. This should generally ensure that human representations and human representations alone are employed by the ML model in its internal thought process. Finally, as a slider of capability, we might gradually shift towards relaxing the translatability constrain by applying it to model \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"shards\"), \" only, rather than holistically. This is analogous to a team of developers working on a codebase, where each one is only responsible for a chunk of it. The codebase is still represented in human brains, but no single brain represents it.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-representational-alignment-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-does-representational-alignment-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-does-representational-alignment-relate-to-concrete-challenges-in-alignment]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"175de8ae-a21d-56db-8fd2-27699bd740d6","fields":{"slug":"/representational-alignment","title":"Representational Alignment"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Differentiable Cosmogonies\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"differentiable-cosmogonies\"\n  }, \"Differentiable Cosmogonies\"), mdx(\"p\", null, \"Training a model on data about the world (e.g. Wikipedia, books, articles, papers, etc.) makes it difficult to box, as it's likely to exploit loopholes in the world (e.g. from physics to sociology) based on its evidence. Given this, we could build a one-way model-to-human channel by tasking the model with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"learning a physics\"), \" which reliably causes lifelike structures to emerge from noise, before us gleaning insights from the resulting structures in a Voyager-pretending-Earth-is-alien sort of way. Life could be operationalized as entropy-fighting across space (e.g. forming unlikely chunks of matter) and time (e.g. changing in unlikely ways from moment to moment), while the physics to be learned could be modeled by a transformer mapping particle-tokens from one timestep to the next. Local-only interactions could help fight the quadratic attention costs, while particle-tokens could have slots for velocity, momentum, and chemical properties, depending on the targeted level of abstraction.\"), mdx(\"p\", null, \"At the moment, I think this is not a particularly promising frame, for two main reasons. First, it might be very difficult to try to understand the emerging aliens beyond mathematical formalism which might as well be framed as a narrow AI task. Second, existing ML models seem to exhibit enough alienness for people to find it insightful to probe them for hours, intentionally going for more alienness might make it no more practical than an Oujia board.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-differentiable-cosmogonies-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-differentiable-cosmogonies-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-differentiable-cosmogonies-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-would-a-training-story-look-like-for-differentiable-colonies\",\n    \"title\": \"how-would-a-training-story-look-like-for-differentiable-colonies\"\n  }, \"[[how-would-a-training-story-look-like-for-differentiable-colonies]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-differentiable-cosmogonies-relate-to-microscope-ai\",\n    \"title\": \"how-do-differentiable-cosmogonies-relate-to-microscope-ai\"\n  }, \"[[how-do-differentiable-cosmogonies-relate-to-microscope-ai]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/could-we-understand-emerging-aliens\",\n    \"title\": \"could-we-understand-emerging-aliens\"\n  }, \"[[could-we-understand-emerging-aliens]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2c3721b1-5de3-5ea1-b694-4055ec9c8136","fields":{"slug":"/differentiable-cosmogonies","title":"Differentiable Cosmogonies"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Home\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"home\"\n  }, \"Home\"), mdx(\"p\", null, \"This is the root note of a (mostly) tree-shaped document which contains my work at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/D7epkkJb3CqDTYgX9/refine-an-incubator-for-conceptual-alignment-research-bets\"\n  }, \"Refine\"), \", an incubator for conceptual research on alignment hosted by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/jfq2BH5kfQqu2vYv3/we-are-conjecture-a-new-alignment-research-startup\"\n  }, \"Conjecture\"), \". I'm using this fellowship as an opportunity to explore several prosaic themes which I currently find promising, and get better at the poking process itself.\"), mdx(\"p\", null, \"Reading all depth-one theme notes should take you around five minutes \\u2014 a deliberate design choice to help you get a quick sense of what this is all about. Afterwards, I recommend switching to a depth-first traversal on whatever branch you find interesting.\"), mdx(\"p\", null, \"I'd find it extremely helpful to hear any targeted feedback you might have via the note-linked comment threads. If possible, consider phrasing it as leading questions which I can then turn into new branches from the note you're commenting on. Best viewed on desktop.\"), mdx(\"h2\", {\n    \"id\": \"themes\"\n  }, \"Themes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/ideological-inference-engines\",\n    \"title\": \"ideological-inference-engines\"\n  }, \"[[ideological-inference-engines]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/oversight-leagues\",\n    \"title\": \"oversight-leagues\"\n  }, \"[[oversight-leagues]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/latent-resonators\",\n    \"title\": \"latent-resonators\"\n  }, \"[[latent-resonators]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/representational-tethers\",\n    \"title\": \"representational-tethers\"\n  }, \"[[representational-tethers]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/concept-programming\",\n    \"title\": \"concept-programming\"\n  }, \"[[concept-programming]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/symbiont-sandboxes\",\n    \"title\": \"symbiont-sandboxes\"\n  }, \"[[symbiont-sandboxes]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/differentiable-cosmogonies\",\n    \"title\": \"differentiable-cosmogonies\"\n  }, \"[[differentiable-cosmogonies]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"appendix\"\n  }, \"Appendix\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/benchmark-scenarios\",\n    \"title\": \"benchmark-scenarios\"\n  }, \"[[benchmark-scenarios]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"571e6790-8b07-5840-82d8-0562f06bb3c9","fields":{"slug":"/hello","title":"Home"}}}]},"fields":{"slug":"/representational-tethers","title":"Representational Tethers"}}},"pageContext":{"id":"d73f0863-33c4-5913-8b6c-e2f1cc555436"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}