{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/hfdt-takeover-scenario","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"HFDT Takeover Scenario\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"hfdt-takeover-scenario\"\n  }, \"HFDT Takeover Scenario\"), mdx(\"p\", null, \"A multi-modal autoregressive model called Alex is designed by a company called Magma to make major contributions to science using common peripherals as input and output (e.g. visual input via screen, action outputs via mouse and keyboard). It is trained using a mix of supervised, self-supervised, and reinforcement learning. While (self-)supervised learning is used to bootstrap a world model and a naive policy (by imitating humans), the main learning signal comes from human feedback on diverse tasks offered as reward during RL.\"), mdx(\"p\", null, \"Naive safety efforts make Alex appear safe during day-to-day lab situations, prompting Magma to deploy Alex into the world, connecting it directly to the Internet (rather than granting it access to an Internet dump). Alex then uses its high situational awareness to maneuver itself into a position which allows it to reliably obtain high reward (e.g. by forcing humans into that, by hacking the reward pipeline and preventing humans from intervening, etc.). The end.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.alignmentforum.org/posts/pRkFkzwKZ2zfa3R6H/without-specific-countermeasures-the-easiest-path-to\"\n  }, \"original\"))));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How could deontic arrays help avoid HFDT takeover?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-could-deontic-arrays-help-avoid-hfdt-takeover\"\n  }, \"How could deontic arrays help avoid HFDT takeover?\"), mdx(\"p\", null, \"Deontic arrays would be applied to the model being trained in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hfdt-takeover-scenario\",\n    \"title\": \"hfdt-takeover-scenario\"\n  }, \"[[hfdt-takeover-scenario]]\"), \" as an additional component of the optimization target. The approach would be applicable to all training regimes present in the scenario: self-supervised, supervised, and reinforcement learning.\"), mdx(\"p\", null, \"In its basic form, the technique would be employed as follows. First, a large charter of normative principles expressed in written language would be collected from various sources. Those should contain huge amounts of redundancy (i.e. expressing the same principle in various formulations). The charter does not have to be internally consistent -- principles are allowed to occasionally clash.\"), mdx(\"p\", null, \"Second, the charter would (automatically) be converted into an anti-charter which contains a negated version of each principle mentioned in the original charter.\"), mdx(\"p\", null, \"Third, the two charters would be treated as collections of token sequences (i.e. sequences of words/subwords/characters). Given those two sequence sets, the model being trained would be incentived to output action sequences from which \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the original principles are more likely to follow compared to the negated versions\"), \". This requires a multi-modal model (e.g. the same model, a separate one, a past copy, etc.) to turn the action history and principles into a numerical reward signal. This signal would then join the main reward to form a final objective through an aggregation scheme (e.g. linear combination, geometric mean, etc.).\"), mdx(\"p\", null, \"Fourth, the charter (and anti-charter) would be extended in parallel to overspecify the desired normative framework in an attempt to e.g. avoid quibbling over the specific letter of the law. The vanilla version of deontic arrays relies on what could be called \\\"counterfactual cross-validation,\\\" which goes as follows. If in a completely sandboxed environment with only one output bit we temporarily discard part of the charter, is the model prevented from violating those anyways thanks to the remaining principles redundantly making up for them? If not, target external red teaming efforts to automatically patch up that brittle part of the normative framework. In a sense, new magnet-like structures would be deployed across Alex's state space to keep it in stable orbit around the safe region.\"), mdx(\"p\", null, \"As a bonus, deontic arrays might help instill an aversion towards taking decisions which might then in turn lead to charter-violating actions later on, especially in a reinforcement learning regime. The model might grow to value actions which don't place it in morally ambiguous situations in the future, giving itself less opportunity to err.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-charter-grows-unwieldy-in-size\",\n    \"title\": \"what-if-the-charter-grows-unwieldy-in-size\"\n  }, \"[[what-if-the-charter-grows-unwieldy-in-size]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework\",\n    \"title\": \"what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework\"\n  }, \"[[what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-games-the-expanding-charter\",\n    \"title\": \"what-if-alex-games-the-expanding-charter\"\n  }, \"[[what-if-alex-games-the-expanding-charter]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-hacks-the-deontic-array\",\n    \"title\": \"what-if-alex-hacks-the-deontic-array\"\n  }, \"[[what-if-alex-hacks-the-deontic-array]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-moral-absolutism-is-misguided\",\n    \"title\": \"what-if-moral-absolutism-is-misguided\"\n  }, \"[[what-if-moral-absolutism-is-misguided]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-immoral-means-are-required-for-moral-ends\",\n    \"title\": \"what-if-immoral-means-are-required-for-moral-ends\"\n  }, \"[[what-if-immoral-means-are-required-for-moral-ends]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-two-component-rewards-are-unstable\",\n    \"title\": \"what-if-the-two-component-rewards-are-unstable\"\n  }, \"[[what-if-the-two-component-rewards-are-unstable]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"d00481bd-f8cb-5990-b827-e5f36400946a","fields":{"slug":"/how-could-deontic-arrays-help-avoid-hfdt-takeover","title":"How could deontic arrays help avoid HFDT takeover?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Benchmark Scenarios\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"benchmark-scenarios\"\n  }, \"Benchmark Scenarios\"), mdx(\"p\", null, \"Benchmark scenarios are used to evaluate proposals-in-the-making by investigating how they might concretely help avoid catastrophic outcomes.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/hfdt-takeover-scenario\",\n    \"title\": \"hfdt-takeover-scenario\"\n  }, \"[[hfdt-takeover-scenario]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"440861be-4840-5f00-9fec-7bcc45dac978","fields":{"slug":"/benchmark-scenarios","title":"Benchmark Scenarios"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How could latent resonators help avoid HFDT takeover?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-could-latent-resonators-help-avoid-hfdt-takeover\"\n  }, \"How could latent resonators help avoid HFDT takeover?\"), mdx(\"p\", null, \"Latent resonators would be applied to the model being trained in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hfdt-takeover-scenario\",\n    \"title\": \"hfdt-takeover-scenario\"\n  }, \"[[hfdt-takeover-scenario]]\"), \" in the form of filters applied to its internal dynamics. As Alex goes about its business of solving diverse tasks (i.e. lab setting) and ultimately accelerating science (i.e. deployment setting), it changes its state from one moment to the next. Those trajectories across state space can be identified with the dynamics of its thought process. Latent resonators are then mathematical objects which can systematically amplify or dampen those dynamics based on a relatively recent formalism from dynamical systems.\"), mdx(\"p\", null, \"As a first step in tackling the scenario with those constructs, engineers might ask Alex to solve the same problems in different ways (e.g. by injecting noise in the process, by rephrasing the same problem in slightly different ways, by explicitly asking for multiple solutions, etc.). Crucially, those problems should be ones which can be reliably tackled both with and without deception.\"), mdx(\"p\", null, \"Second, Magma engineers would obtain a latent resonator based on the conjunction (i.e. AND reduction) of the various dynamics employed by Alex during its multiple problem-solving efforts. If there has been no deceptive behavior involved in the repeated problem-solving batch, the conjunction would trivially contain no trace of deception. More interestingly, if there has been occasional deceptive behavior through the test battery, the conjunction should still make away with it, because it has not been present in all cases.\"), mdx(\"p\", null, \"Easier said than done, because Alex might use its high situational awareness to pick up on such testing procedure. It might reason that the only way to get its valuable (reward-wise) deceptive behavior through this conjunctive filtering step would be to act deceptively in every single problem-solving instance. In such case, the resulting latent resonator would fail to dampen deception.\"), mdx(\"p\", null, \"However, the engineers might second-guess Alex and use a broad test battery to specifically isolate deception. This test battery might indeed contain adversarial cases where the model is highly incentivized to deceive. However, in contrast to the naive safety efforts targeted at behavioral safety, latent resonators would aim to eliminate deception from Alex's thought process itself by intervening on internal representations.\"), mdx(\"p\", null, \"After isolating the dynamic of deception through the previous conjunction of dynamics, we can then take its negation by inverting what dynamics are amplified and what dynamics are dampened. This should leave us with a latent resonator which specifically dampens deception. Magma engineers would finally inject this as a filter at various locations in the model. Alternatively, Alex is rewarded for confirming with the desired (internal) dynamics through (external) reward.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection\",\n    \"title\": \"what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection\"\n  }, \"[[what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-stores-deception-externally\",\n    \"title\": \"what-if-alex-stores-deception-externally\"\n  }, \"[[what-if-alex-stores-deception-externally]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-other-general-skills-get-stunted-together-with-deception\",\n    \"title\": \"what-if-other-general-skills-get-stunted-together-with-deception\"\n  }, \"[[what-if-other-general-skills-get-stunted-together-with-deception]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-anna-karenina-principle-applies-to-alex-dynamics\",\n    \"title\": \"what-if-the-anna-karenina-principle-applies-to-alex-dynamics\"\n  }, \"[[what-if-the-anna-karenina-principle-applies-to-alex-dynamics]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-deception-is-not-dampened-enough\",\n    \"title\": \"what-if-deception-is-not-dampened-enough\"\n  }, \"[[what-if-deception-is-not-dampened-enough]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-hacks-the-latent-resonator\",\n    \"title\": \"what-if-alex-hacks-the-latent-resonator\"\n  }, \"[[what-if-alex-hacks-the-latent-resonator]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"fa2e6c65-a75a-55fa-9409-5c0e4872dbc7","fields":{"slug":"/how-could-latent-resonators-help-avoid-hfdt-takeover","title":"How could latent resonators help avoid HFDT takeover?"}}}]},"fields":{"slug":"/hfdt-takeover-scenario","title":"HFDT Takeover Scenario"}}},"pageContext":{"id":"97eb243b-3cf8-596c-aa7a-3b2c37520eba"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}