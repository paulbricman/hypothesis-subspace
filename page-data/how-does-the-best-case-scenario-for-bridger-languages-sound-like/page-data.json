{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/how-does-the-best-case-scenario-for-bridger-languages-sound-like","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How does the base case scenario for bridger languages sound like?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-does-the-base-case-scenario-for-bridger-languages-sound-like\"\n  }, \"How does the base case scenario for bridger languages sound like?\"), mdx(\"p\", null, \"After people getting used to using synthetic interlingua for gaining insight into the internal representations of ML models, the previous approach of dealing with high-dimensional vectors in forced ways would feel like going back to doing maths in written multiple-paragraph proofs, rather than using compact mathematical notation. That is, the current version would feel infinitely less expressive and brain-friendly than the interlingua. Moreover, the process of engineering latent activations to be more cognitively ergonomic would feel like a natural complement to the process of adapting humans to deal with unwieldy ML models through augmentation. It would help make the model's thoughts more easy to be perceived by humans.\"), mdx(\"p\", null, \"Planning, and ideation in lucrative domains (e.g. scientific research) remains difficult for humans to do, but proves easy for humans to verify, providing humanity deeper oversight abilities to help keep AGI in check. This might mean unraveling plans for human disempowerment, getting our hands on latent knowledge of advanced technologies, etc. In a sense, the model would be transparent from day one, before any transparency tool would be employed to timidly open the black box.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-might-an-interlingua-look-like\",\n    \"title\": \"how-might-an-interlingua-look-like\"\n  }, \"[[how-might-an-interlingua-look-like]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-bottleneck-layer-is-too-constraining\",\n    \"title\": \"what-if-the-bottleneck-layer-is-too-constraining\"\n  }, \"[[what-if-the-bottleneck-layer-is-too-constraining]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-training-humans-is-not-feasible\",\n    \"title\": \"what-if-training-humans-is-not-feasible\"\n  }, \"[[what-if-training-humans-is-not-feasible]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-interlingua-is-an-attack-vector\",\n    \"title\": \"what-if-interlingua-is-an-attack-vector\"\n  }, \"[[what-if-interlingua-is-an-attack-vector]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-handle-interlingua-dialects\",\n    \"title\": \"how-to-handle-interlingua-dialects\"\n  }, \"[[how-to-handle-interlingua-dialects]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How might an interlingua look like?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-might-an-interlingua-look-like\"\n  }, \"How might an interlingua look like?\"), mdx(\"p\", null, \"I'll provide one sample stretching commonsense conceptions of languages to hint at promising directions to explore. Let's call it \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"bridgespeak\"), \". Imagine a 2D honeycomb-like lattice of symbols. Symbols differentiate themselves across pre-attentive features like color, orientation, spatial frequency, etc. Symbols would relate to each other due to structural biases for local interactions enforced during the language creation process (i.e. during training ML models). Besides the appearance of symbols being somewhat disconnected from established writing systems (mainly due to the constraints of writing by hand on a flat surface), symbols might pack a similar amount of composable meaning to Chinese logograms which can mix together to create sentences resembling megawords (due to no explicit word delimination).\"), mdx(\"p\", null, \"There might be a couple of similar dialects with different symbols and lattice shapes, originating from different ML models. Children would learn some of those early on due to their particular language learning abilities, in order to become familiar with the AGI's thought process. Besides, deliberate practice at later ages combined with potential social incentives to learn an interlingua might further help promote proficiency.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"3ffbb78d-5b93-5700-9a49-3573b9dbd0d9","fields":{"slug":"/how-might-an-interlingua-look-like","title":"How might an interlingua look like?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if the bottleneck layer is too constraining?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-the-bottleneck-layer-is-too-constraining\"\n  }, \"What if the bottleneck layer is too constraining?\"), mdx(\"p\", null, \"Enforcing local structure over latent activations and forcing their components to conform to a cookbook of quantized vectors might result in an inconvenient alignment tax on the performance of ML models, despite making internal representations more human-friendly. Fortunately, the few techniques available todayfor improving the interpretability of ML models using conventional transparency tools (e.g. SoLU) don't seem to incur significant capability penalties, which is encouraging.\"), mdx(\"p\", null, \"Still, it might be the case that one \\\"sentence\\\" expressed in the interlingua takes one person a lot of time to parse out and understand. Local structure constraints might help break down the representations into decently decoupled chunks before people reconvening to piece the puzzle. It's unclear how much this could scale, though. Imagine tasking a thousand people with reading one page of a thousand-page book, before reconvening. This runs into HCH-like conceptual limitations.\"), mdx(\"p\", null, \"Conversely, instead of horizontally splitting out the interlingua sentence, one might imagine a hierarchical variation which contains a top-level representation before zooming in on meanings. In the hexagonal toy example from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/how-might-an-interlingua-look-like\",\n    \"title\": \"how-might-an-interlingua-look-like\"\n  }, \"[[how-might-an-interlingua-look-like]]\"), \", one might imagine having a top-level lattice, where each symbol can be zoomed into, resulting in a nested lattice. Flows of information during learning, and hence the resulting local structure, would match the links contained in the hierarchy. That said, the devil might lost be in low-level details of combinatorial size.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"bf907c45-4476-5076-b0fd-0cef3c5870ef","fields":{"slug":"/what-if-the-bottleneck-layer-is-too-constraining","title":"What if the bottleneck layer is too constraining?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if training humans is not feasible?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-training-humans-is-not-feasible\"\n  }, \"What if training humans is not feasible?\"), mdx(\"p\", null, \"Perhaps the internal representations used by the ML model are so alien that trying to teach humans this foreign language would fail spectacularly. The main source of replies to this family of counterarguments might come from the fact that the ML model itself is incentivized to use its representational resources efficiently, striking a balance between \\\"speaker economy\\\" and \\\"message clarity\\\". We have reasons to believe the ML model's internal language and human languages might exhibit convergent evolution due to the perks of resource efficiency.\"), mdx(\"p\", null, \"Still, despite the ML model coming up with its own internal \\\"mathematical\\\" instead of \\\"written multiple-paragraph\\\", for various parts of its conceptual framework, it might still be too advanced. Imagine having to learn Chinese in one-week tops (as an attempt to artificially constrain capabilities and at the same time boost the difficulty of a human-made problem into superhuman territory). Alternatively, imagine teaching non-human primates to write coherent English by pressing on a keyboard. Unlikely to happen to a reliable extent.\"), mdx(\"p\", null, \"This feels like the opposite side of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/what-if-the-bottleneck-layer-is-too-constraining\",\n    \"title\": \"what-if-the-bottleneck-layer-is-too-constraining\"\n  }, \"[[what-if-the-bottleneck-layer-is-too-constraining]]\"), \" struggle. It might be interesting to add additional constraints on the internal representation inspired by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \" to help bring the two modes of thought closer, in order to avoid this clash in sophistication. This might refer to both making the model's representations easier to perceive (the realm of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bridger-languages\",\n    \"title\": \"bridger-languages\"\n  }, \"[[bridger-languages]]\"), \"), but also closer to the human thing (the realm of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \").\"), mdx(\"p\", null, \"Another approach would be to split the task of acquiring the ML model's language into subtask through a chain of bridger languages. The whole chain would be learned by the ML model, where each element of the chain would be constrained to be within a threshold of divergence (e.g. KL divergence) with its neighboring languages. Additionally, the one end of the chain would have to be a human language. Following this, people would gradually learn to bridge the representational gap. Potentially, new generations might gradually move across the gap, each internalizing a more alien version of the language, which would come to feel natural.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"cd6362e8-2d2d-5819-a8da-e5f1fa4f0879","fields":{"slug":"/what-if-training-humans-is-not-feasible","title":"What if training humans is not feasible?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if interlingua is an attack vector?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-interlingua-is-an-attack-vector\"\n  }, \"What if interlingua is an attack vector?\"), mdx(\"p\", null, \"If humans would be familiar and exposed to the ML model's internal language, it might be the case that the ML model considers influencing humans through this channel, in an attempt to maneuver itself into a position which allows it to reliably obtain high reward. However, if the ML model would consider this, this very thought should be legible to people, as a tiny control lever.\"), mdx(\"p\", null, \"Anyway, assuming oversight is not applied to that particular thought pattern due to limited human resources, can the model think manipulative thoughts to fool its mind-readers? Given the fact the entirety of the thought patterns would be required to pass through the bottleneck language identified with the interlingua, there is no other place from which the ML model would orchestrate this deceptive plan. However, it might decide to act in a given way, and then intentionally forget the reason for that so that humans wouldn't be able to pick up those intentions through the interlingua.\"), mdx(\"p\", null, \"Additionally, it might be that even if humans are aware of human-incompatible plans put together by the ML model, they would be powerless in tackling them at that point. The model wouldn't really care about using the interlingua as an attack vector, because that wouldn't help push its agenda.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"af49d60e-1171-5f11-ac06-b40090b8e284","fields":{"slug":"/what-if-interlingua-is-an-attack-vector","title":"What if interlingua is an attack vector?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to handle interlingua dialects?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-to-handle-interlingua-dialects\"\n  }, \"How to handle interlingua dialects?\"), mdx(\"p\", null, \"Training multiple models might lead to different emerging flavors of synthetic interlingua(s). This might translate to humans being familiar with a host of them, with time investment driven by the multi-polar dynamics of the associated AGIs. There's also a question of bridging questions. Humans comunicating with augmented humans through a bridger language, before augmented humans comunicate with AGI through a different one. Beyond a cliche SF trope, it's not entirely clear how those intermediate entities would be like, how fast would humanness fade across the spectrum, etc.\"), mdx(\"p\", null, \"In such a bridger chain of languages, there would be a problem of information being lost in translation, at the intermediate points of \\\"bilingual\\\" speakers along the chain. However, in the vanilla formulation, such phenomena might be less likely, because the very premise is that both sides use one shared language as a common ground for their interaction.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"b8970597-375c-5a8b-a30e-edd10b2c79ca","fields":{"slug":"/how-to-handle-interlingua-dialects","title":"How to handle interlingua dialects?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Bridger Languages\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bridger-languages\"\n  }, \"Bridger Languages\"), mdx(\"p\", null, \"Interpretability tools generally assume no prior training on the part of humans when dissecting a model's internal representations. What if we allowed for explicit human training in a bridging language which is directly employed by a model? This might require us to apply principles of cognitive ergonomics to a bottleneck layer (e.g. sparsity, local structure, discreteness, Gestalt-aware symbols), so that humans could become fluent in the bridging language. A nested lattice of quantized \\\"logograms\\\" might be fitting, and young children might be particularly fit for the role of bridging the two different modes of thought. Pairs of artifacts in familiar modalities (e.g. text, images, videos) and associated translations could form the basis of the learning process, together with any discovered syntax of the emerging language.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-bridger-languages-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-bridger-languages-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-bridger-languages-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-the-best-case-scenario-for-bridger-languages-sound-like\",\n    \"title\": \"how-does-the-best-case-scenario-for-bridger-languages-sound-like\"\n  }, \"[[how-does-the-best-case-scenario-for-bridger-languages-sound-like]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"3ab0b7b0-6877-526c-b13a-7f15ce7f5792","fields":{"slug":"/bridger-languages","title":"Bridger Languages"}}}]},"fields":{"slug":"/how-does-the-best-case-scenario-for-bridger-languages-sound-like","title":"How does the base case scenario for bridger languages sound like?"}}},"pageContext":{"id":"957720e2-6f9c-53fe-944e-c4f30dd458a1"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}