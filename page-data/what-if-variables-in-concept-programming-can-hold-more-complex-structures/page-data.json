{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/what-if-variables-in-concept-programming-can-hold-more-complex-structures","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if variables in concept programming can hold more complex structures?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-variables-in-concept-programming-can-hold-more-complex-structures\"\n  }, \"What if variables in concept programming can hold more complex structures?\"), mdx(\"p\", null, \"In conventional programming, variables can be of more than just base types, they can be of custom types which involve more complex class-like structures. Does the concept programming metaphor preserve this property?\"), mdx(\"p\", null, \"A concept might consist in the relation between two concepts, but that would still be a base concept, except for its weird skew so that it facilitates the mapping between the two during some defined addition or join. A set of concepts might help specify a conceptual framework, so perhaps a set or list or tuple of concepts might be a sensible addition. Custom types are less easy to justify, as a set of concepts would inevitably find themselves in a certain interrelation pattern and hence lack the need for additional context provided through fields of more abstract entities.\"), mdx(\"p\", null, \"This design choice picks up on an important disanalogy between conventional programming and concept programming. In conventional programming, variables are not implicitly related other than e.g. through a specified chain of operations. In concept programming, concepts are implicitly related through their interrelations, likely expressible as ops on distributions over semantic space. \"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Concept Programming\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"concept-programming\"\n  }, \"Concept Programming\"), mdx(\"p\", null, \"This frame is an iteration of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/abstraction-inductors\",\n    \"title\": \"abstraction-inductors\"\n  }, \"[[abstraction-inductors]]\"), \", yet it's sufficiently different from the previous version to warrant a new node. Concept programming is the process of systematically modifying the conceptual framework internalized by an ML model. To go with the analogy, concept programming languages generally include the following components:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"variables / symbols\"), \": The variable \\\"fruit\\\" is a container for the concept of fruit.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"values / concepts\"), \": The concept of fruit is contained in the \\\"fruit\\\" variable.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"assignment\"), \": Assigning a concept to a symbol is identified with heavily tweaking the ML model's ontology to reflect that.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"initialization\"), \": Initializing a new symbol is identified with creating a tabula rasa association-free entity in the model's ontology (e.g. a fresh new token).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"concept operators\"), \": Taking the conjunction of \\\"Apple\\\" and \\\"Microsoft\\\" might yield a concept of big tech company. Boolean and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://paulbricman.com/thoughtware/semantica\"\n  }, \"Semantica-like\"), \" ops are low-hanging fruit here.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"flow operators\"), \": Basic if/for/while/switch/... structures for guiding the concept program.\")), mdx(\"p\", null, \"The application idea is that using a concept program which incorporates multiple of those elements, the model's internal ontology could be systematically tweaked towards useful outcomes. For instance, this might mean forming suitable abstractions of human values, or discouraging abstractions which are at odds with those.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\",\n    \"title\": \"how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\"\n  }, \"[[how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks\",\n    \"title\": \"can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks\"\n  }, \"[[can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-variables-in-concept-programming-can-hold-more-complex-structures\",\n    \"title\": \"what-if-variables-in-concept-programming-can-hold-more-complex-structures\"\n  }, \"[[what-if-variables-in-concept-programming-can-hold-more-complex-structures]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"c0f9eba5-fb3f-5a6a-8ef3-df41c5e1a4f9","fields":{"slug":"/concept-programming","title":"Concept Programming"}}}]},"fields":{"slug":"/what-if-variables-in-concept-programming-can-hold-more-complex-structures","title":"What if variables in concept programming can hold more complex structures?"}}},"pageContext":{"id":"21ac0454-ec65-54e5-ac31-59b9c708f4a4"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}