{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/how-to-handle-interlingua-dialects","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to handle interlingua dialects?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-to-handle-interlingua-dialects\"\n  }, \"How to handle interlingua dialects?\"), mdx(\"p\", null, \"Training multiple models might lead to different emerging flavors of synthetic interlingua(s). This might translate to humans being familiar with a host of them, with time investment driven by the multi-polar dynamics of the associated AGIs. There's also a question of bridging questions. Humans comunicating with augmented humans through a bridger language, before augmented humans comunicate with AGI through a different one. Beyond a cliche SF trope, it's not entirely clear how those intermediate entities would be like, how fast would humanness fade across the spectrum, etc.\"), mdx(\"p\", null, \"In such a bridger chain of languages, there would be a problem of information being lost in translation, at the intermediate points of \\\"bilingual\\\" speakers along the chain. However, in the vanilla formulation, such phenomena might be less likely, because the very premise is that both sides use one shared language as a common ground for their interaction.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How does the base case scenario for bridger languages sound like?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-does-the-base-case-scenario-for-bridger-languages-sound-like\"\n  }, \"How does the base case scenario for bridger languages sound like?\"), mdx(\"p\", null, \"After people getting used to using synthetic interlingua for gaining insight into the internal representations of ML models, the previous approach of dealing with high-dimensional vectors in forced ways would feel like going back to doing maths in written multiple-paragraph proofs, rather than using compact mathematical notation. That is, the current version would feel infinitely less expressive and brain-friendly than the interlingua. Moreover, the process of engineering latent activations to be more cognitively ergonomic would feel like a natural complement to the process of adapting humans to deal with unwieldy ML models through augmentation. It would help make the model's thoughts more easy to be perceived by humans.\"), mdx(\"p\", null, \"Planning, and ideation in lucrative domains (e.g. scientific research) remains difficult for humans to do, but proves easy for humans to verify, providing humanity deeper oversight abilities to help keep AGI in check. This might mean unraveling plans for human disempowerment, getting our hands on latent knowledge of advanced technologies, etc. In a sense, the model would be transparent from day one, before any transparency tool would be employed to timidly open the black box.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-might-an-interlingua-look-like\",\n    \"title\": \"how-might-an-interlingua-look-like\"\n  }, \"[[how-might-an-interlingua-look-like]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-bottleneck-layer-is-too-constraining\",\n    \"title\": \"what-if-the-bottleneck-layer-is-too-constraining\"\n  }, \"[[what-if-the-bottleneck-layer-is-too-constraining]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-training-humans-is-not-feasible\",\n    \"title\": \"what-if-training-humans-is-not-feasible\"\n  }, \"[[what-if-training-humans-is-not-feasible]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-interlingua-is-an-attack-vector\",\n    \"title\": \"what-if-interlingua-is-an-attack-vector\"\n  }, \"[[what-if-interlingua-is-an-attack-vector]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-handle-interlingua-dialects\",\n    \"title\": \"how-to-handle-interlingua-dialects\"\n  }, \"[[how-to-handle-interlingua-dialects]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"957720e2-6f9c-53fe-944e-c4f30dd458a1","fields":{"slug":"/how-does-the-best-case-scenario-for-bridger-languages-sound-like","title":"How does the base case scenario for bridger languages sound like?"}}}]},"fields":{"slug":"/how-to-handle-interlingua-dialects","title":"How to handle interlingua dialects?"}}},"pageContext":{"id":"b8970597-375c-5a8b-a30e-edd10b2c79ca"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}