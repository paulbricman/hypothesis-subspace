{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/how-much-could-expansion-heuristics-help","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How much could expansion heuristics help?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-much-could-expansion-heuristics-help\"\n  }, \"How much could expansion heuristics help?\"), mdx(\"p\", null, \"It seems sensible that nudging knowledge base expansion towards \\\"relevant\\\" regions (i.e. on the topic of verification target) would help alleviate a combinatorial explosion in knowledge base size. However, what's the upper bound of how much expansion heuristics can help?\"), mdx(\"p\", null, \"Text is cheap to store, and actions might be too, so the knowledge base itself might be relatively large without major technical issues (e.g. billions of items). Semantic search using bi-encoders scales pretty nicely assuming cached embeddings, due to efficient approximate neighbor algorithms. The main bottleneck appear to be the pair-wise ops between the relevant knowledge base items and the verification target. Additionally, each expansion step is relatively costly (e.g. requires LLMs).\"), mdx(\"p\", null, \"Expansion heuristics might help guide the investment of compute during expansion steps towards relevant regions, but their use in the entailment might be limited. On a related note, knowledge base expansion appears quite parallelizable if focusing on different patches at the same time or different self-play debate runs.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How would backward-chaining work in ideological inference engines?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-would-backward-chaining-work-in-ideological-inference-engines\"\n  }, \"How would backward-chaining work in ideological inference engines?\"), mdx(\"p\", null, \"The initial inference mechanisms considered in IIE based on the previous merged frames feel like forward-chaining. The target proposition or behavior has no say in the way the knowledge base expands in those original means of expansion. However, it might be useful to guide the expansion towards regions which appear relevant to dealing with the new items to be verified.\"), mdx(\"p\", null, \"For instance, instead of targeting the charter expansion towards normative regions which are not redundantly accounted for by other principles, it might be interesting to partially guide the expansion towards normative regions relevant to the item to be verified. For instance, if most principles in the charter (i.e. most items in the knowledge base) are unrelated to the item to be verified, it might be sensible to focus on expanding on ones which are a bit related. Of course, there might be a round-about way of getting to relevant propositions, echoing the shortcomings of heuristics in general.\"), mdx(\"p\", null, \"As another example, one might imagine incentivizing the competing memeplexes in a debate (one of which is the one to be extrapolated), to align with the item to be verified. Due to competitive pressures, not all will do, providing at the same time a heuristic towards expanding on topic and an entailment verification mechanism (i.e. checking if the main memeplex gets to buy into the item to be verified).\"), mdx(\"p\", null, \"As another example, one might imagine injecting the verification target into the memeplex to be extrapolated, and seeing how it reacts. If it radically diverges to maintain consistency, then it might not be compatible. If it stays on track, it might be. However, this feels more like an active version of Overton probing, rather than a search heuristic. Though it still forces the debate towards the topic. What if you'd inject the verification target in one timeline and its negation in other and measured which one diverged least, a mix between the original \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \".\"), mdx(\"p\", null, \"As mentioned before, some approaches to backward-chaining feel like complementing the inference mechanism (e.g. nudging charter expansion to be on topic), while some others feel like implementing new entailment verifiers (e.g. injecting the verification target and observing memetic developments). They might still be decoupled into inference mechanism and entailment verifier, even if they go together and are coupled. If they're not truly coupled they might even yield generative effect.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-much-could-expansion-heuristics-help\",\n    \"title\": \"how-much-could-expansion-heuristics-help\"\n  }, \"[[how-much-could-expansion-heuristics-help]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"2e808b87-cd25-58bd-aac3-13bde6dce02c","fields":{"slug":"/how-would-backward-chaining-work-in-ideological-inference-engines","title":"How would backward-chaining work in ideological inference engines?"}}}]},"fields":{"slug":"/how-much-could-expansion-heuristics-help","title":"How much could expansion heuristics help?"}}},"pageContext":{"id":"541bfe00-4b27-5100-8502-3109b24990d7"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}