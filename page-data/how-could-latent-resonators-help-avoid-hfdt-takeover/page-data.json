{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/how-could-latent-resonators-help-avoid-hfdt-takeover","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How could latent resonators help avoid HFDT takeover?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-could-latent-resonators-help-avoid-hfdt-takeover\"\n  }, \"How could latent resonators help avoid HFDT takeover?\"), mdx(\"p\", null, \"Latent resonators would be applied to the model being trained in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hfdt-takeover-scenario\",\n    \"title\": \"hfdt-takeover-scenario\"\n  }, \"[[hfdt-takeover-scenario]]\"), \" in the form of filters applied to its internal dynamics. As Alex goes about its business of solving diverse tasks (i.e. lab setting) and ultimately accelerating science (i.e. deployment setting), it changes its state from one moment to the next. Those trajectories across state space can be identified with the dynamics of its thought process. Latent resonators are then mathematical objects which can systematically amplify or dampen those dynamics based on a relatively recent formalism from dynamical systems.\"), mdx(\"p\", null, \"As a first step in tackling the scenario with those constructs, engineers might ask Alex to solve the same problems in different ways (e.g. by injecting noise in the process, by rephrasing the same problem in slightly different ways, by explicitly asking for multiple solutions, etc.). Crucially, those problems should be ones which can be reliably tackled both with and without deception.\"), mdx(\"p\", null, \"Second, Magma engineers would obtain a latent resonator based on the conjunction (i.e. AND reduction) of the various dynamics employed by Alex during its multiple problem-solving efforts. If there has been no deceptive behavior involved in the repeated problem-solving batch, the conjunction would trivially contain no trace of deception. More interestingly, if there has been occasional deceptive behavior through the test battery, the conjunction should still make away with it, because it has not been present in all cases.\"), mdx(\"p\", null, \"Easier said than done, because Alex might use its high situational awareness to pick up on such testing procedure. It might reason that the only way to get its valuable (reward-wise) deceptive behavior through this conjunctive filtering step would be to act deceptively in every single problem-solving instance. In such case, the resulting latent resonator would fail to dampen deception.\"), mdx(\"p\", null, \"However, the engineers might second-guess Alex and use a broad test battery to specifically isolate deception. This test battery might indeed contain adversarial cases where the model is highly incentivized to deceive. However, in contrast to the naive safety efforts targeted at behavioral safety, latent resonators would aim to eliminate deception from Alex's thought process itself by intervening on internal representations.\"), mdx(\"p\", null, \"After isolating the dynamic of deception through the previous conjunction of dynamics, we can then take its negation by inverting what dynamics are amplified and what dynamics are dampened. This should leave us with a latent resonator which specifically dampens deception. Magma engineers would finally inject this as a filter at various locations in the model. Alternatively, Alex is rewarded for conforming with the desired (internal) dynamics through (external) reward.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection\",\n    \"title\": \"what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection\"\n  }, \"[[what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-stores-deception-externally\",\n    \"title\": \"what-if-alex-stores-deception-externally\"\n  }, \"[[what-if-alex-stores-deception-externally]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-other-general-skills-get-stunted-together-with-deception\",\n    \"title\": \"what-if-other-general-skills-get-stunted-together-with-deception\"\n  }, \"[[what-if-other-general-skills-get-stunted-together-with-deception]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-anna-karenina-principle-applies-to-alex-dynamics\",\n    \"title\": \"what-if-the-anna-karenina-principle-applies-to-alex-dynamics\"\n  }, \"[[what-if-the-anna-karenina-principle-applies-to-alex-dynamics]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-deception-is-not-dampened-enough\",\n    \"title\": \"what-if-deception-is-not-dampened-enough\"\n  }, \"[[what-if-deception-is-not-dampened-enough]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-hacks-the-latent-resonator\",\n    \"title\": \"what-if-alex-hacks-the-latent-resonator\"\n  }, \"[[what-if-alex-hacks-the-latent-resonator]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"HFDT Takeover Scenario\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"hfdt-takeover-scenario\"\n  }, \"HFDT Takeover Scenario\"), mdx(\"p\", null, \"A multi-modal autoregressive model called Alex is designed by a company called Magma to make major contributions to science using common peripherals as input and output (e.g. visual input via screen, action outputs via mouse and keyboard). It is trained using a mix of supervised, self-supervised, and reinforcement learning. While (self-)supervised learning is used to bootstrap a world model and a naive policy (by imitating humans), the main learning signal comes from human feedback on diverse tasks offered as reward during RL.\"), mdx(\"p\", null, \"Naive safety efforts make Alex appear safe during day-to-day lab situations, prompting Magma to deploy Alex into the world, connecting it directly to the Internet (rather than granting it access to an Internet dump). Alex then uses its high situational awareness to maneuver itself into a position which allows it to reliably obtain high reward (e.g. by forcing humans into that, by hacking the reward pipeline and preventing humans from intervening, etc.). The end.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.alignmentforum.org/posts/pRkFkzwKZ2zfa3R6H/without-specific-countermeasures-the-easiest-path-to\"\n  }, \"original\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"97eb243b-3cf8-596c-aa7a-3b2c37520eba","fields":{"slug":"/hfdt-takeover-scenario","title":"HFDT Takeover Scenario"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex spreads out its deception dynamics to avoid detection?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection\"\n  }, \"What if Alex spreads out its deception dynamics to avoid detection?\"), mdx(\"p\", null, \"While our understanding of such dynamics is in its infancy (e.g. how crisp are they even?), one plausible failure mode of using latent resonators here would be that Alex spreads out its internal pattern of deception into distinct specialized skills. It might intentionally conceive of deception in question answering on a specific topic in a fundamentally different way than in question answering on a different topic.\"), mdx(\"p\", null, \"While the original attempt to isolate a general deceptive dynamic might fail because of no \\\"constructive interference\\\" across situations, all is not lost. First, the very fact that Alex invests representational resources on different flavors of deception might be detected. The formalism underlying latent resonators has successfully been used to quantify the \\\"available storage space\\\" for novel dynamics in RNNs across a few toy problems. Similar techniques might help us keep tabs on Alex's investments in representational resources for its different patterns.\"), mdx(\"p\", null, \"Additionally, if deception flavors are somehow successfully isolated despite there being multiple of them, Magma researchers can take the disjunction of those nasty variants and negate \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"that\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"1bbb8f25-b0cd-586c-862d-c35022563053","fields":{"slug":"/what-if-alex-spreads-out-its-deception-dynamics-to-avoid-detection","title":"What if Alex spreads out its deception dynamics to avoid detection?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex stores deception externally?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-stores-deception-externally\"\n  }, \"What if Alex stores deception externally?\"), mdx(\"p\", null, \"In the scenario, Alex is allowed to make use of miscellaneous desktop applications like Google Docs. This ability combined with its situational awareness of the inner workings of latent resonators might prompt it to represent its deceptive dynamics externally. Whether this would mean writing up a \\\"human_deception.docx\\\" or encoding information through steganography in an image, Alex might save instructions for later, without memorizing them and hence evading representational filters.\"), mdx(\"p\", null, \"However, it would still need to read them and act on them, staining its blissfully-ignorant internal representations with deceptive undertakings. The latent resonators would pick up \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"this\"), \" pattern instead and dampen it drastically. Alternatively, Alex might be forced to start from a blank slate environment each time, though that would significantly hinder its capabilities. Humanity builds on previous breakthroughs through culture, and we might be nowhere near our current abilities without it.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"6ad37184-bf79-5d85-ae5e-5ac7837e3a44","fields":{"slug":"/what-if-alex-stores-deception-externally","title":"What if Alex stores deception externally?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if other general skills get stunted together with deception?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-other-general-skills-get-stunted-together-with-deception\"\n  }, \"What if other general skills get stunted together with deception?\"), mdx(\"p\", null, \"It might be tricky to successfully isolate deception dynamics without touching a bit on other general cognitive skills which Alex might employ across problem-solving contexts. Eliciting \\\"raw\\\" deception via adversarial examples might be a particularly handy way of responding to this. Similarly, eliciting pure deception in different contexts might help single out underlying dynamics.\"), mdx(\"p\", null, \"Another approach would be to deal with different snapshots of Alex obtained during its training. If one snapshot was taken just before teaching Alex deception, that might help single it out for targeted removal. However, its newly acquired skill might have shifted its other internalized patterns in funny ways, making the subtraction messier as a means of singling out the \\\"signature\\\" of deception.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"c30b2fe7-1acc-5bd5-acbf-00dd691e3f3f","fields":{"slug":"/what-if-other-general-skills-get-stunted-together-with-deception","title":"What if other general skills get stunted together with deception?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if the Anna Karenina principle applies to Alex dynamics?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-the-anna-karenina-principle-applies-to-alex-dynamics\"\n  }, \"What if the Anna Karenina principle applies to Alex dynamics?\"), mdx(\"p\", null, \"Aligned dynamics might only be a tiny cluster, while misaligned ones might take on a whole range of flavors. This might mean that aiming to isolate and neutralize specific dynamics (e.g. deception) might turn out worthless, as Alex always has new tricks up its sleeve. Efforts focused on taking the conjunction of whitelisted dynamics rather than negating blacklisted ones might turn out more promising in that case. However, deception appears quite fundamental across a broad range of manipulative tactics, bringing into question the applicability of the AK principle here. But perhaps Alex could overtly persuade human operators even without deception (e.g. blackmail).\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"d8f5ea48-7dab-5cfb-8376-9f3b6028ad3b","fields":{"slug":"/what-if-the-anna-karenina-principle-applies-to-alex-dynamics","title":"What if the Anna Karenina principle applies to Alex dynamics?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if deception is not dampened enough?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-deception-is-not-dampened-enough\"\n  }, \"What if deception is not dampened enough?\"), mdx(\"p\", null, \"Dampening is less decisive than eliminating. The \\\"excision\\\" of deception would be imperfect, leaving traces of undesirable behavior in Alex. However, a bit of hope comes from the drive of autoregressive models to strive towards coherence, to collapse the metaphorical Necker cube and systematically resolve ambiguity towards attractors of likelihood. Given this, removing \\\"enough\\\" deception might be sufficient, without eliminating it completely. The pattern might be present, but often (kept) dormant enough save for adversarial circumstances.\"), mdx(\"p\", null, \"If Magma engineers can't get the excision exactly right and deception turns out to be stepping on some other general skill in an awkward tango, then the amount of residue might form a trade-off with capability. This might unfortunately bring up an alignment tax deemed inconvenient, but it depends on the nature and separability of Alex's dynamics.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2ea70674-f884-5dd7-996c-e22b202bb6bb","fields":{"slug":"/what-if-deception-is-not-dampened-enough","title":"What if deception is not dampened enough?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex hacks the latent resonator?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-hacks-the-latent-resonator\"\n  }, \"What if Alex hacks the latent resonator?\"), mdx(\"p\", null, \"Alex might realize the latent resonator hinders its ability to obtain reward (e.g. via deception). It might then be appealing to hack the latent resonators and make away with those damn constraints. I don't think latent resonators provide a way of making this unthinkable for Alex, except by trying to isolate and excise the specific drive by first eliciting it. Perhaps deception is just one convergent and nasty pattern, and a relatively easy one at that, because you can elicit it without instant game over. But perhaps you can elicit thought patterns related to hacking by asking Alex to solve CTF challenges at DefCon and then point at that?\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"750ed7e3-353f-50ed-9ed1-32a78cfba64d","fields":{"slug":"/what-if-alex-hacks-the-latent-resonator","title":"What if Alex hacks the latent resonator?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Latent Resonators\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"latent-resonators\"\n  }, \"Latent Resonators\"), mdx(\"p\", null, \"In the context of autoregressive models, prompts are often seen as \\\"programs\\\" which specify various behaviors for the model to \\\"run\\\" next. What if we framed prompts as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"resonance chambers\"), \" of different shapes and sizes which amplify certain dynamics while dampening others? The goal would then be to devise such constructs which reliably make away with misaligned spectral components, and apply them directly to latent activations. One promising way of doing this relies on a new formalism from dynamical systems which defines an entire Boolean logic of dynamics. By taking the conjunction of whitelisted dynamics and negating blacklisted ones, we can craft and inject filters in ML models while only incurring minimal compute overhead. The layer depth of the injection site might also offer a slider between influencing the way a model \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"perceives\"), \" the world and the way it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"acts\"), \" in given circumstances.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-latent-resonators-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-latent-resonators-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-latent-resonators-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-could-latent-resonators-help-avoid-hfdt-takeover\",\n    \"title\": \"how-could-latent-resonators-help-avoid-hfdt-takeover\"\n  }, \"[[how-could-latent-resonators-help-avoid-hfdt-takeover]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"22da8d58-963c-5f3c-abaa-d6c84cbe1faa","fields":{"slug":"/latent-resonators","title":"Latent Resonators"}}}]},"fields":{"slug":"/how-could-latent-resonators-help-avoid-hfdt-takeover","title":"How could latent resonators help avoid HFDT takeover?"}}},"pageContext":{"id":"fa2e6c65-a75a-55fa-9409-5c0e4872dbc7"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}