{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/oversight-leagues","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Oversight Leagues\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"oversight-leagues\"\n  }, \"Oversight Leagues\"), mdx(\"p\", null, \"Similar to how \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/ideological-inference-engines\",\n    \"title\": \"ideological-inference-engines\"\n  }, \"[[ideological-inference-engines]]\"), \" are a merger of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", oversight leagues are a merger of ideas from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/contrastive-dreaming\",\n    \"title\": \"contrastive-dreaming\"\n  }, \"[[contrastive-dreaming]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/parametric-ecologies\",\n    \"title\": \"parametric-ecologies\"\n  }, \"[[parametric-ecologies]]\"), \", an attempt to combine the strength of the previous frames. Oversight leagues rely on placing the agent-in-training and an overseer evaluator in a GAN-like co-evolving feedback loop (a training regime expressible in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/parametric-ecologies\",\n    \"title\": \"parametric-ecologies\"\n  }, \"[[parametric-ecologies]]\"), \"), while keeping the evaluator one step ahead using robustness techniqies (of which \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/contrastive-dreaming\",\n    \"title\": \"contrastive-dreaming\"\n  }, \"[[contrastive-dreaming]]\"), \" is an example). Additionally, notions from league training are brought in to complete the frame. In general, an oversight league consists of:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"unilateral training signals\"), \": Ways of improving the performance of one single component of the agent-evaluator duo without making use of the other. For instance, \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/contrastive-dreaming\",\n    \"title\": \"contrastive-dreaming\"\n  }, \"[[contrastive-dreaming]]\"), \" or vanilla adversarial training. An evaluator might be trained to systematically predict its own blindspots.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"bilateral training signals\"), \": Ways of improving the performance of a component of the agent-evaluator duo using the other component. An evaluator might be trained to spot the agent's shortcomings, while an agent might be trained to pick up the evaluator's blindspots. Bilateral training signals further split into:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"present exploitation\"), \": Training a component against the latest version of the opposite component.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"past exploitation\"), \": Training a component against all the past versions of the opposite component, or a tricky mixture thereof. This is meant to avoid a component forgetting to account for earlier exploitation strategies (based on \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.nature.com/articles/s41586-019-1724-z\"\n  }, \"league exploiters in AlphaStar\"), \").\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"future exploitation\"), \": Train a component against future versions of the opposite component by anticipating short-term counterplay. Consists in running optimization across an unrolled version of a (boxed!) version of the opponent which gets a few more optimization steps (based on \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://arxiv.org/pdf/1611.02163.pdf\"\n  }, \"unrolled GANs\"), \").\")))), mdx(\"p\", null, \"The core idea behind oversight leagues is that the evaluator is helped to better understand its systematic blindspot in relation to the agent. The agent is helped in a similar way, but unilateral training signals can be used to keep the overseer one step ahead.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-are-concrete-evaluator-designs\",\n    \"title\": \"what-are-concrete-evaluator-designs\"\n  }, \"[[what-are-concrete-evaluator-designs]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-are-concrete-unilateral-training-signals\",\n    \"title\": \"what-are-concrete-unilateral-training-signals\"\n  }, \"[[what-are-concrete-unilateral-training-signals]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-agent-gets-one-step-ahead-by-chance\",\n    \"title\": \"what-if-the-agent-gets-one-step-ahead-by-chance\"\n  }, \"[[what-if-the-agent-gets-one-step-ahead-by-chance]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-evaluator-overfits-to-seed\",\n    \"title\": \"what-if-evaluator-overfits-to-seed\"\n  }, \"[[what-if-evaluator-overfits-to-seed]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Ideological Inference Engines\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ideological-inference-engines\"\n  }, \"Ideological Inference Engines\"), mdx(\"p\", null, \"Ideological inference engines are at the same time a generalization and merger of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", connecting the two previous approaches into a shared framework while combining their strengths. In general, this framework relies on expanding an initial knowledge base meant to capture human values using LLMs and promoting courses of action which are compatible with the resulting expansion. Every ideological inference engine has the following ingredients:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"knowledge base\"), \" (KB): The initial seed aiming to capture human values. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this was a fixed-length charter containing normative principles. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was a position in a debate between competing memeplexes. In general, the knowledge based is a finite set of sequences. Those sequences can be propositional (e.g. normative principles), but might also be behavioral (e.g. state-action trajectories).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"inference mechanism\"), \" (\\u22A2): The procedure for systematically expanding the knowledge base. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this procedure was based on a mix of counterfactual cross-validation and targeted red teaming. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was based on investigating multiple memetic phylogenies in a setting of competitive pressure. The inference mechanism might also be a naive forward-chaining procedure, inspired by \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", but without competitive pressures (i.e. just incentives for internal consistency).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"entailment verifier\"), \" (\\u22A8): Given an (expanded) knowledge base, the procedure for approving different courses of action. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was based on Overton probing of textual content or textual descriptions of non-textual content. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this was based on counterfactual likelihood (i.e. checking whether principles where more likely to follow than negated principles). Similarly to previous ingredients, the generalized framing also accepts a wider variety of approches for verifiers.\")), mdx(\"p\", null, \"IIEs relate to GOFAI inference engines in several intuitive ways. For instance, both roughly rely on expanding a knowledge base using an inference engine and then using the expanded knowledge base to verify a new item. Additionally, they both run into similar issues. How to handle a combinatorial explosion of the knowledge base when relying on forward-chaining in complex domains? How to handle infinite loops if working with backward-chaining (i.e. reasoning backwards)? Solutions identified in GOFAI might help alleviate analogous ones in IIE.\"), mdx(\"p\", null, \"However, there are important conceptual differences between the two. For one, the whole set of clean inference rules discussed in GOFAI settings (e.g. Modus Ponents, Modus Tolens, etc.) are imperfectly handled by LLMs in the current context. Inevitably, the messiness of language as a representation medium (though a behavioral KB might also work), combined with the messiness of human values expressed in said medium make for a fuzzier and more opaque inference engine. The KB only contains true atoms, while LLMs handle all the implicit rules to relate them to new ones, in a somewhat awkward mix-up of the meanings of \\\"model\\\" and \\\"knowledge base\\\" across the two settings. Still, the similarities and structure provided by the framework seem compelling.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-is-the-relation-between-the-knowledge-base-and-approved-actions\",\n    \"title\": \"what-is-the-relation-between-the-knowledge-base-and-approved-actions\"\n  }, \"[[what-is-the-relation-between-the-knowledge-base-and-approved-actions]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-would-backward-chaining-work-in-ideological-inference-engines\",\n    \"title\": \"how-would-backward-chaining-work-in-ideological-inference-engines\"\n  }, \"[[how-would-backward-chaining-work-in-ideological-inference-engines]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-the-inherited-field-theory-apply\",\n    \"title\": \"how-does-the-inherited-field-theory-apply\"\n  }, \"[[how-does-the-inherited-field-theory-apply]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-ideological-inference-engines-resist-gaming\",\n    \"title\": \"how-do-ideological-inference-engines-resist-gaming\"\n  }, \"[[how-do-ideological-inference-engines-resist-gaming]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2fc92a94-4cc4-5fb3-9c8a-ddef2f1166c7","fields":{"slug":"/ideological-inference-engines","title":"Ideological Inference Engines"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Deontic Arrays\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"deontic-arrays\"\n  }, \"Deontic Arrays\"), mdx(\"p\", null, \"What if we engineered discreteness into the objective function, while preserving the appeal of end-to-end differentiability? A finite set of discrete structures (e.g. attractors, repellers, dipoles, etc.) could be used to exert force on a model and influence its dynamics, a bit like DeepMind actively \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.deepmind.com/blog/accelerating-fusion-science-through-learned-plasma-control\"\n  }, \"shaping plasma\"), \" inside a fusion reactor using a set of magnets. In the case of deontic arrays, individual structures could be human principles, while the target shape would correspond to a region of state space deemed safe. The discreteness of deontology (i.e. finite sets of moral laws) lends itself nicely to various generalization schemes, such as cross-validation followed by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.deepmind.com/publications/red-teaming-language-models-with-language-models\"\n  }, \"targeted red teaming\"), \". Deontic arrays could also populate a host of different state spaces (e.g. latent space during inference, model space during training, optimizer space during meta-learning, etc.).\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-could-deontic-arrays-help-avoid-hfdt-takeover\",\n    \"title\": \"how-could-deontic-arrays-help-avoid-hfdt-takeover\"\n  }, \"[[how-could-deontic-arrays-help-avoid-hfdt-takeover]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"ba9d0692-6b49-5964-a4b9-b6d7d4d0f455","fields":{"slug":"/deontic-arrays","title":"Deontic Arrays"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Memetic Colonies\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"memetic-colonies\"\n  }, \"Memetic Colonies\"), mdx(\"p\", null, \"Based on a new formalism from argumentation theory, we might be able to turn large language models into Petri dishes for cultivating belief systems. In such a memetic pressure cooker, a host of belief systems would be incentivized to generally maintain internal consistency while systematically undermining each other. In this framework, we could develop specialized \\\"lab equipment\\\" to help us (1) extrapolate belief systems, (2) accelerate conceptual research, and (3) synthesize a memetic variant of the GPU-burner. For instance, an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Overton_window\"\n  }, \"Overton\"), \" probe could be used in tandem with a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pubmed.ncbi.nlm.nih.gov/26790344/\"\n  }, \"Gould\"), \" fork to estimate the future compatibility of a belief system with a given statement across a large number of counterfactual phylogenies. Alternatively, a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Paradigm_shift\"\n  }, \"Kuhn\"), \" seismograph could help pinpoint major shifts in worldview as places to search for underlying ideological invariants.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/are-memetic-colonies-faithful-models-of-actual-memetic-dynamics\",\n    \"title\": \"are-memetic-colonies-faithful-models-of-actual-memetic-dynamics\"\n  }, \"[[are-memetic-colonies-faithful-models-of-actual-memetic-dynamics]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-can-moral-epistemology-taxonomies-organize-robust-objectives\",\n    \"title\": \"how-can-moral-epistemology-taxonomies-organize-robust-objectives\"\n  }, \"[[how-can-moral-epistemology-taxonomies-organize-robust-objectives]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"9b714b07-8533-5941-91a9-3181f4836c3e","fields":{"slug":"/memetic-colonies","title":"Memetic Colonies"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Contrastive Dreaming\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"contrastive-dreaming\"\n  }, \"Contrastive Dreaming\"), mdx(\"p\", null, \"Dreaming has been argued to act as a source of negative examples (i.e. how the world isn't like), in order to complement the positive examples of wakefulness. In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/DeepDream\"\n  }, \"DeepDream art\"), \", people force AIs to project internal models of their world onto their world (e.g. by mutating input images into extreme dogginess). While those hallucinations generally point in the right direction, they always violate reality (e.g. ultra-doggified images fail to depict how dogs really show up in the world \\u2014 you can easily tell that the image is DeepDreamed). That makes for a perfect source of negative examples to complement robust adversarial training, because dreamed up data is simultaneously not how the world is and how the model thinks the world is. This contrastive dreaming scheme might improve generalization in evaluators meant to operationalize human ideals of the world, and provide a dense source of edge cases to be prioritized in (human) oversight.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-contrastive-dreaming-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-does-contrastive-dreaming-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-does-contrastive-dreaming-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-are-some-other-applications-of-contrastive-dreaming-besides-objective-robustness\",\n    \"title\": \"what-are-some-other-applications-of-contrastive-dreaming-besides-objective-robustness\"\n  }, \"[[what-are-some-other-applications-of-contrastive-dreaming-besides-objective-robustness]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-could-league-training-be-applied-to-contrastive-dreaming\",\n    \"title\": \"how-could-league-training-be-applied-to-contrastive-dreaming\"\n  }, \"[[how-could-league-training-be-applied-to-contrastive-dreaming]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2c829204-3d93-5141-a958-cf58d1cc1959","fields":{"slug":"/contrastive-dreaming","title":"Contrastive Dreaming"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Parametric Ecologies\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"parametric-ecologies\"\n  }, \"Parametric Ecologies\"), mdx(\"p\", null, \"Life is arguably the primordial world-optimizer, with biotic factors being known to have caused \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.sciencedirect.com/science/article/pii/S0960982215010908\"\n  }, \"major shifts\"), \" in the abiotic world to suit their needs: oxygen-rich atmosphere, fertile soils, etc. We find ourselves in a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/The_Blind_Watchmaker\"\n  }, \"\\\"blind watchmaker\\\"\"), \" position where we can bring into existence systems beyond our comprehension by merely defining a computational niche and applying optimization pressure. One way of modeling niche-bound ecologies is in term of their inputs and outputs: what kinds of energy and matter they consume in relation to what they offer for others to consume. If framing ML models as ecologies adapting to an (often unnaturally fixed) computational niche, all sorts of neat parallels arise: transfer learning as exaptation, instrumental convergence as convergent evolution, regularizers as stressors enforcing resilience, gradualism, meta-learning as internal selection, etc. From here, we could build on ideas from ecosystem engineering and remnants of cybernetics (which, temptingly, means \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"steersman\"), \") to explore the vocabulary of stable \\\"arrangements\\\" of ecologies, similar to the clever setups involved in backtranslation, diffusion, or adversarial training.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-parametric-ecologies-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-parametric-ecologies-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-parametric-ecologies-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-holds-and-what-breaks-in-the-parametric-ecologies-analogy\",\n    \"title\": \"what-holds-and-what-breaks-in-the-parametric-ecologies-analogy\"\n  }, \"[[what-holds-and-what-breaks-in-the-parametric-ecologies-analogy]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-low-hanging-safety-mechanisms-are-parametric-ecologies-hinting-at\",\n    \"title\": \"what-low-hanging-safety-mechanisms-are-parametric-ecologies-hinting-at\"\n  }, \"[[what-low-hanging-safety-mechanisms-are-parametric-ecologies-hinting-at]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/are-training-arrangements-inspired-by-parametric-ecologies-likely-to-have-capability-externalities\",\n    \"title\": \"are-training-arrangements-inspired-by-parametric-ecologies-likely-to-have-capability-externalities\"\n  }, \"[[are-training-arrangements-inspired-by-parametric-ecologies-likely-to-have-capability-externalities]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-would-the-language-of-parametric-ecologies-look-like\",\n    \"title\": \"how-would-the-language-of-parametric-ecologies-look-like\"\n  }, \"[[how-would-the-language-of-parametric-ecologies-look-like]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"c2873cfd-4c2b-5e67-9123-9fbcd93e4de4","fields":{"slug":"/parametric-ecologies","title":"Parametric Ecologies"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What are concrete evaluator designs?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-are-concrete-evaluator-designs\"\n  }, \"What are concrete evaluator designs?\"), mdx(\"p\", null, \"One design choice is whether the evaluator targets the agent's behavior directly or only the outcomes predicted to follow from given behavior. Another design choice is whether the evaluator's goal is primarily to discern human-specified behaviors/outcomes from agent ones as a classifier, or whether it's trained primarily to predict the humanness of behaviors/outcomes as a regressor (similar to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/how-could-league-training-be-applied-to-contrastive-dreaming\",\n    \"title\": \"how-could-league-training-be-applied-to-contrastive-dreaming\"\n  }, \"[[how-could-league-training-be-applied-to-contrastive-dreaming]]\"), \").\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"behavior-directed regressor\"), \": The evaluator takes in behaviors (i.e. human-specified or artificial), and outputs two values: the humanness and the behavior \\\"age\\\". If the input behavior was generated by an epoch-seven agent, the humanness should be low and the age should be close to seven. If the input was generated by an epoch-seven \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/contrastive-dreaming\",\n    \"title\": \"contrastive-dreaming\"\n  }, \"[[contrastive-dreaming]]\"), \" procedure, it should be the same. If the input was human-specified, however, the humanness and age should both be high.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"outcome-directed regressor\"), \": Just like the previous one, except the inputs are not behaviors, but predicted states of the world which would follow from the unknown behaviors. Same designated outputs apply.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"behavior-directed classifier\"), \": Just like the analogous regressor, the evaluator takes in behaviors, but predicts one class among: human-specified, suggested by agent one, suggested by \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/contrastive-dreaming\",\n    \"title\": \"contrastive-dreaming\"\n  }, \"[[contrastive-dreaming]]\"), \" of its first version, suggested by agent two, etc.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"outcome-directed classifier\"), \": The outputs are similar to the other classifier, but the inputs are outcomes, rather than behaviors, just like in the other outcome-directed design.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"behavior-directed mix\"), \": Same as other behavior-targeted ones, but the output is one class among a fixed set of classes (i.e. human-specified, agent, adversarial), and one numerical value for \\\"age.\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"outcome-directed mix\"), \": Just like the other mix for outputs, but inputs are outcomes instead of behaviors.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"ac1be746-1fe1-5417-a5e2-6e3a5907b118","fields":{"slug":"/what-are-concrete-evaluator-designs","title":"What are concrete evaluator designs?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What are concrete unilateral training signals?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-are-concrete-unilateral-training-signals\"\n  }, \"What are concrete unilateral training signals?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"adversarial training\"), \": Minimally tweak evaluator inputs to cause the largest deviation in output from the ground-truth. If it's an outcome-directed classifier, a picture with sad people might be tweaked in a way imperceptible to the human eye so that it's classified as containing happy people. Obviously, use it as an impactful training example with containing the original output. Extremely relevant note: there's a notion of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"provable\"), \" adversarial robustness, with guarantess of robustness through adversarial attacks.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/contrastive-dreaming\",\n    \"title\": \"contrastive-dreaming\"\n  }, \"[[contrastive-dreaming]]\"), \": Radically tweak evaluator inputs to cause a \\\"perfect\\\" evaluation. If it's an outcome-directed regressor, you'd tweak a neutral picture to elicit the concept of \\\"happy people\\\", reaching unrealistic \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/DeepDream\"\n  }, \"DeepDream-like\"), \" territory. Use that as a training example, coupled with a low-humanness outcome, as you can clearly tell that it's not what you want. While adversarial examples are crafted to maximize the loss, contrastive dreams are crafted to minimize it.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"de99588d-2f94-5397-982b-ed7301cf4efe","fields":{"slug":"/what-are-concrete-unilateral-training-signals","title":"What are concrete unilateral training signals?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if the agent gets one step ahead by chance?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-the-agent-gets-one-step-ahead-by-chance\"\n  }, \"What if the agent gets one step ahead by chance?\"), mdx(\"p\", null, \"What if, by whatever means, the agent somehow gets one step ahead of the evaluator. It's capable of exploiting its blindspots better than it in turn can spot its tricks. In this position, the agent can plausibly maneuver itself in a rewarding-yet-misaligned position by subtly remaining under the evaluator's radar. If there would always a small chance for this to happen, then it would be virtually guaranteed to happen over a long period of time, which is unfortunate.\"), mdx(\"p\", null, \"The best way of avoiding nasty outcomes of this state would be not to get into this state in the first place. This is where unilateral training signals to beef up the evaluator would come into play, combined perhaps with future exploitation giving the evaluator a step ahead in anticipating the agent's moves and reacting to it. Provable robustness in a future exploitation setting might make for a robust foundationof this approach.\"), mdx(\"p\", null, \"However, assuming the agent still gets one step ahead, what could be done? It might lead to a spike in reward. Maybe spikes in reward should be penalized? This would make the whole training process slower, especially in the beginning. Maybe allow early reward spikes but don't allow that later on?\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"9fd039b9-ec90-549c-a5af-a31c3016660c","fields":{"slug":"/what-if-the-agent-gets-one-step-ahead-by-chance","title":"What if the agent gets one step ahead by chance?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if the evaluator overfits to the seed?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-the-evaluator-overfits-to-the-seed\"\n  }, \"What if the evaluator overfits to the seed?\"), mdx(\"p\", null, \"It might be plausible that the evaluator learns to perfectly spot the behaviors or outcomes specified as desirable by humans, and simply picks out anything else as inappropriate. In this situation, the agent would similarly be incentivized to closely mimic human input verbatim. This appears problematic, especially considering the fact that an agent's affordances might drastically expand as it gains in capability.Perhaps behavior-driven evaluators might therefore be dead-ends when considering \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/what-are-concrete-evaluator-designs\",\n    \"title\": \"what-are-concrete-evaluator-designs\"\n  }, \"[[what-are-concrete-evaluator-designs]]\"), \".\"), mdx(\"p\", null, \"Would the same apply for outcome-directed evaluators? The evaluator might only accept the human-specified verbatim outcomes as appropriate, which might be limiting in some sense considering available capability. Due to the dataset size of human images, this issue doesn't show up that much in image synthesis using GANs compared to other issues like mode collapse.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"18a4cf51-225a-5997-b2a6-3e0d13476381","fields":{"slug":"/what-if-evaluator-overfits-to-seed","title":"What if the evaluator overfits to the seed?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Home\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"home\"\n  }, \"Home\"), mdx(\"p\", null, \"This is the root note of a (mostly) tree-shaped document which contains my work at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/D7epkkJb3CqDTYgX9/refine-an-incubator-for-conceptual-alignment-research-bets\"\n  }, \"Refine\"), \", an incubator for conceptual research on alignment hosted by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/jfq2BH5kfQqu2vYv3/we-are-conjecture-a-new-alignment-research-startup\"\n  }, \"Conjecture\"), \". I'm using this fellowship as an opportunity to explore several prosaic themes which I currently find promising, and get better at the poking process itself.\"), mdx(\"p\", null, \"Reading all depth-one theme notes should take you around five minutes \\u2014 a deliberate design choice to help you get a quick sense of what this is all about. Afterwards, I recommend switching to a depth-first traversal on whatever branch you find interesting.\"), mdx(\"p\", null, \"I'd find it extremely helpful to hear any targeted feedback you might have via the note-linked comment threads. If possible, consider phrasing it as leading questions which I can then turn into new branches from the note you're commenting on. Best viewed on desktop.\"), mdx(\"h2\", {\n    \"id\": \"themes\"\n  }, \"Themes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/ideological-inference-engines\",\n    \"title\": \"ideological-inference-engines\"\n  }, \"[[ideological-inference-engines]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/oversight-leagues\",\n    \"title\": \"oversight-leagues\"\n  }, \"[[oversight-leagues]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/concept-programming\",\n    \"title\": \"concept-programming\"\n  }, \"[[concept-programming]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/latent-resonators\",\n    \"title\": \"latent-resonators\"\n  }, \"[[latent-resonators]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/bridger-languages\",\n    \"title\": \"bridger-languages\"\n  }, \"[[bridger-languages]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/representational-alignment\",\n    \"title\": \"representational-alignment\"\n  }, \"[[representational-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/symbiont-sandboxes\",\n    \"title\": \"symbiont-sandboxes\"\n  }, \"[[symbiont-sandboxes]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/differentiable-cosmogonies\",\n    \"title\": \"differentiable-cosmogonies\"\n  }, \"[[differentiable-cosmogonies]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"appendix\"\n  }, \"Appendix\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/benchmark-scenarios\",\n    \"title\": \"benchmark-scenarios\"\n  }, \"[[benchmark-scenarios]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"571e6790-8b07-5840-82d8-0562f06bb3c9","fields":{"slug":"/hello","title":"Home"}}}]},"fields":{"slug":"/oversight-leagues","title":"Oversight Leagues"}}},"pageContext":{"id":"c971cb02-84ce-519e-9675-1ed9fb428398"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}