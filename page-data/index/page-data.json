{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Home\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"home\"\n  }, \"Home\"), mdx(\"p\", null, \"This is the root note of a (mostly) tree-shaped document which contains my work at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/D7epkkJb3CqDTYgX9/refine-an-incubator-for-conceptual-alignment-research-bets\"\n  }, \"Refine\"), \", an incubator for conceptual research on alignment hosted by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/jfq2BH5kfQqu2vYv3/we-are-conjecture-a-new-alignment-research-startup\"\n  }, \"Conjecture\"), \". I'm using this fellowship as an opportunity to explore several prosaic themes which I currently find promising, and get better at the poking process itself.\"), mdx(\"p\", null, \"Reading all depth-one theme notes should take you around five minutes \\u2014 a deliberate design choice to help you get a quick sense of what this is all about. Afterwards, I recommend switching to a depth-first traversal on whatever branch you find interesting.\"), mdx(\"p\", null, \"I'd find it extremely helpful to hear any targeted feedback you might have via the note-linked comment threads. If possible, consider phrasing it as leading questions which I can then turn into new branches from the note you're commenting on. Best viewed on desktop.\"), mdx(\"h2\", {\n    \"id\": \"themes\"\n  }, \"Themes\"), mdx(\"p\", null, \"Roughly spanning a spectrum from addressing outer to inner alignment:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" \\uD83D\\uDD0D\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" \\uD83D\\uDD0D\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/parametric-ecologies\",\n    \"title\": \"parametric-ecologies\"\n  }, \"[[parametric-ecologies]]\"), \" \\uD83D\\uDD0D\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/contrastive-dreaming\",\n    \"title\": \"contrastive-dreaming\"\n  }, \"[[contrastive-dreaming]]\"), \" \\uD83D\\uDD0D\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/symbiont-sandboxes\",\n    \"title\": \"symbiont-sandboxes\"\n  }, \"[[symbiont-sandboxes]]\"), \" \\uD83C\\uDCCF\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/differentiable-cosmogonies\",\n    \"title\": \"differentiable-cosmogonies\"\n  }, \"[[differentiable-cosmogonies]]\"), \" \\uD83C\\uDCCF\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/abstraction-inductors\",\n    \"title\": \"abstraction-inductors\"\n  }, \"[[abstraction-inductors]]\"), \" \\uD83D\\uDCA4\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/synthetic-interlingua\",\n    \"title\": \"synthetic-interlingua\"\n  }, \"[[synthetic-interlingua]]\"), \" \\uD83D\\uDCA4\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/physicalist-fluency\",\n    \"title\": \"physicalist-fluency\"\n  }, \"[[physicalist-fluency]]\"), \" \\uD83D\\uDCA4\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/latent-resonators\",\n    \"title\": \"latent-resonators\"\n  }, \"[[latent-resonators]]\"), \" \\uD83D\\uDD0D\")), mdx(\"p\", null, \"(\\uD83D\\uDD0D under investigation \\uD83D\\uDCA4 awaiting initial survey \\uD83C\\uDCCFwildcard)\"), mdx(\"h2\", {\n    \"id\": \"appendix\"\n  }, \"Appendix\"), mdx(\"p\", null, \"Mostly meta-science considerations as opposed to the object-level ideas:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/benchmark-scenarios\",\n    \"title\": \"benchmark-scenarios\"\n  }, \"[[benchmark-scenarios]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Process\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Artifact\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Background\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Next Steps\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Refiner Blogroll\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Acknowledgements\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Memetic Colonies\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"memetic-colonies\"\n  }, \"Memetic Colonies\"), mdx(\"p\", null, \"Based on a new formalism from argumentation theory, we might be able to turn large language models into Petri dishes for cultivating belief systems. In such a memetic pressure cooker, a host of belief systems would be incentivized to generally maintain internal consistency while systematically undermining each other. In this framework, we could develop specialized \\\"lab equipment\\\" to help us (1) extrapolate belief systems, (2) accelerate conceptual research, and (3) synthesize a memetic variant of the GPU-burner. For instance, an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Overton_window\"\n  }, \"Overton\"), \" probe could be used in tandem with a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pubmed.ncbi.nlm.nih.gov/26790344/\"\n  }, \"Gould\"), \" fork to estimate the future compatibility of a belief system with a given statement across a large number of counterfactual phylogenies. Alternatively, a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Paradigm_shift\"\n  }, \"Kuhn\"), \" seismograph could help pinpoint major shifts in worldview as places to search for underlying ideological invariants.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/are-memetic-colonies-faithful-models-of-actual-memetic-dynamics\",\n    \"title\": \"are-memetic-colonies-faithful-models-of-actual-memetic-dynamics\"\n  }, \"[[are-memetic-colonies-faithful-models-of-actual-memetic-dynamics]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"9b714b07-8533-5941-91a9-3181f4836c3e","fields":{"slug":"/memetic-colonies","title":"Memetic Colonies"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Deontic Arrays\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"deontic-arrays\"\n  }, \"Deontic Arrays\"), mdx(\"p\", null, \"What if we engineered discreteness into the objective function, while preserving the appeal of end-to-end differentiability? A finite set of discrete structures (e.g. attractors, repellers, dipoles, etc.) could be used to exert force on a model and influence its dynamics, a bit like DeepMind actively \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.deepmind.com/blog/accelerating-fusion-science-through-learned-plasma-control\"\n  }, \"shaping plasma\"), \" inside a fusion reactor using a set of magnets. In the case of deontic arrays, individual structures could be human principles, while the target shape would correspond to a region of state space deemed safe. The discreteness of deontology (i.e. finite sets of moral laws) lends itself nicely to various generalization schemes, such as cross-validation followed by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.deepmind.com/publications/red-teaming-language-models-with-language-models\"\n  }, \"targeted red teaming\"), \". Deontic arrays could also populate a host of different state spaces (e.g. latent space during inference, model space during training, optimizer space during meta-learning, etc.).\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-could-deontic-arrays-help-avoid-hfdt-takeover\",\n    \"title\": \"how-could-deontic-arrays-help-avoid-hfdt-takeover\"\n  }, \"[[how-could-deontic-arrays-help-avoid-hfdt-takeover]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"ba9d0692-6b49-5964-a4b9-b6d7d4d0f455","fields":{"slug":"/deontic-arrays","title":"Deontic Arrays"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Parametric Ecologies\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"parametric-ecologies\"\n  }, \"Parametric Ecologies\"), mdx(\"p\", null, \"Life is arguably the primordial world-optimizer, with biotic factors being known to have caused \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.sciencedirect.com/science/article/pii/S0960982215010908\"\n  }, \"major shifts\"), \" in the abiotic world to suit their needs: oxygen-rich atmosphere, fertile soils, etc. We find ourselves in a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/The_Blind_Watchmaker\"\n  }, \"\\\"blind watchmaker\\\"\"), \" position where we can bring into existence systems beyond our comprehension by merely defining a computational niche and applying optimization pressure. One way of modeling niche-bound ecologies is in term of their inputs and outputs: what kinds of energy and matter they consume in relation to what they offer for others to consume. If framing ML models as ecologies adapting to an (often unnaturally fixed) computational niche, all sorts of neat parallels arise: transfer learning as exaptation, instrumental convergence as convergent evolution, regularizers as stressors enforcing resilience, gradualism, meta-learning as internal selection, etc. From here, we could build on ideas from ecosystem engineering and remnants of cybernetics (which, temptingly, means \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"steersman\"), \") to explore the vocabulary of stable \\\"arrangements\\\" of ecologies, similar to the clever setups involved in backtranslation, diffusion, or adversarial training.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-parametric-ecologies-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-parametric-ecologies-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-parametric-ecologies-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-holds-and-what-breaks-in-the-parametric-ecologies-analogy\",\n    \"title\": \"what-holds-and-what-breaks-in-the-parametric-ecologies-analogy\"\n  }, \"[[what-holds-and-what-breaks-in-the-parametric-ecologies-analogy]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-low-hanging-safety-mechanisms-are-parametric-ecologies-hinting-at\",\n    \"title\": \"what-low-hanging-safety-mechanisms-are-parametric-ecologies-hinting-at\"\n  }, \"[[what-low-hanging-safety-mechanisms-are-parametric-ecologies-hinting-at]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/are-training-arrangements-inspired-by-parametric-ecologies-likely-to-have-capability-externalities\",\n    \"title\": \"are-training-arrangements-inspired-by-parametric-ecologies-likely-to-have-capability-externalities\"\n  }, \"[[are-training-arrangements-inspired-by-parametric-ecologies-likely-to-have-capability-externalities]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-would-the-language-of-parametric-ecologies-look-like\",\n    \"title\": \"how-would-the-language-of-parametric-ecologies-look-like\"\n  }, \"[[how-would-the-language-of-parametric-ecologies-look-like]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"c2873cfd-4c2b-5e67-9123-9fbcd93e4de4","fields":{"slug":"/parametric-ecologies","title":"Parametric Ecologies"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Contrastive Dreaming\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"contrastive-dreaming\"\n  }, \"Contrastive Dreaming\"), mdx(\"p\", null, \"Dreaming has been argued to act as a source of negative examples (i.e. how the world isn't like), in order to complement the positive examples of wakefulness. In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/DeepDream\"\n  }, \"DeepDream art\"), \", people force AIs to project internal models of their world onto their world (e.g. by mutating input images into extreme dogginess). While those hallucinations generally point in the right direction, they always violate reality (e.g. ultra-doggified images fail to depict how dogs really show up in the world \\u2014 you can easily tell that the image is DeepDreamed). That makes for a perfect source of negative examples to complement robust adversarial training, because dreamed up data is simultaneously not how the world is and how the model thinks the world is. This contrastive dreaming scheme might improve generalization in evaluators meant to operationalize human ideals of the world, and provide a dense source of edge cases to be prioritized in (human) oversight.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-contrastive-dreaming-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-does-contrastive-dreaming-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-does-contrastive-dreaming-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-are-some-other-applications-of-contrastive-dreaming-besides-objective-robustness\",\n    \"title\": \"what-are-some-other-applications-of-contrastive-dreaming-besides-objective-robustness\"\n  }, \"[[what-are-some-other-applications-of-contrastive-dreaming-besides-objective-robustness]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2c829204-3d93-5141-a958-cf58d1cc1959","fields":{"slug":"/contrastive-dreaming","title":"Contrastive Dreaming"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Symbiont Sandboxes\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"symbiont-sandboxes\"\n  }, \"Symbiont Sandboxes\"), mdx(\"p\", null, \"One of the most impressive works of Escher depict \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.wikiart.org/en/m-c-escher/mosaic-ii\"\n  }, \"mosaics of creatures\"), \" coexisting in a shared space. The shape assumed by one creature is perfectly determined by the shapes of its neighbors, while it in turn helps shape its neighbors. What if we used a similar design to build a testbed for communities of world-optimizing agents? In an identification of map and territory, each agent would aim to remake the image-world in its own image, by representing itself across a larger and larger patch of the image-world. Imperfect sensors could be simulated by allowing read access to only a subset of neighboring pixels, and potentially adding noise. Similarly, imperfect actuators could be simulated by stunting write access (i.e. \\\"agent #3 hasn't mastered this aspect of physics\\\"). Could clever objective specs help avoid a monopoly on resources? What would be the kinetics of a sharp increase in granted optimization power?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-symbiont-sandboxes-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-symbiont-sandboxes-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-symbiont-sandboxes-relate-to-concrete-challenges-in-alignment]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"3281a8b1-af2a-5f01-9678-4e0844536912","fields":{"slug":"/symbiont-sandboxes","title":"Symbiont Sandboxes"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Differentiable Cosmogonies\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"differentiable-cosmogonies\"\n  }, \"Differentiable Cosmogonies\"), mdx(\"p\", null, \"Training a model on data about the world (e.g. Wikipedia, books, articles, papers, etc.) makes it difficult to box, as it's likely to exploit loopholes in the world (e.g. from physics to sociology) based on its evidence. Given this, we could build a one-way model-to-human channel by tasking the model with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"learning a physics\"), \" which reliably causes lifelike structures to emerge from noise, before us gleaning insights from the resulting structures in a Voyager-pretending-Earth-is-alien sort of way. Life could be operationalized as entropy-fighting across space (e.g. forming unlikely chunks of matter) and time (e.g. changing in unlikely ways from moment to moment), while the physics to be learned could be modeled by a transformer mapping particle-tokens from one timestep to the next. Local-only interactions could help fight the quadratic attention costs, while particle-tokens could have slots for velocity, momentum, and chemical properties, depending on the targeted level of abstraction.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-differentiable-cosmogonies-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-differentiable-cosmogonies-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-differentiable-cosmogonies-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-would-a-training-story-look-like-for-differentiable-colonies\",\n    \"title\": \"how-would-a-training-story-look-like-for-differentiable-colonies\"\n  }, \"[[how-would-a-training-story-look-like-for-differentiable-colonies]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-differentiable-cosmogonies-relate-to-microscope-ai\",\n    \"title\": \"how-do-differentiable-cosmogonies-relate-to-microscope-ai\"\n  }, \"[[how-do-differentiable-cosmogonies-relate-to-microscope-ai]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2c3721b1-5de3-5ea1-b694-4055ec9c8136","fields":{"slug":"/differentiable-cosmogonies","title":"Differentiable Cosmogonies"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Abstraction Inductors\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"abstraction-inductors\"\n  }, \"Abstraction Inductors\"), mdx(\"p\", null, \"Initial results from a recent interpretability technique (incidentally, my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fse.studenttheses.ub.rug.nl/27840/1/NSCv5.pdf\"\n  }, \"bachelor's thesis\"), \"), indicate that it's possible to extract parts of a transformer's internal ontology directly from latent activations, without making use of outputs at all. Analysing internal representations directly also has the benefit of making the technique modality-agnostic. Given this class of interpretability tools, what if we directly conditioned the model's ontological structure during training so as to force it to correctly learn the concept of human values in relation to other unconditioned concepts? This might either involve using a blank slate token with no other connotations or building on an existing symbol like \\\"human values\\\" and conditioning its internal representation.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-abstraction-inductors-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-abstraction-inductors-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-abstraction-inductors-relate-to-concrete-challenges-in-alignment]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"b9f495b9-5a5b-5c58-aa27-d79c7509c592","fields":{"slug":"/abstraction-inductors","title":"Abstraction Inductors"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Synthetic Interlingua\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"synthetic-interlingua\"\n  }, \"Synthetic Interlingua\"), mdx(\"p\", null, \"Interpretability tools generally assume no prior training on the part of humans when dissecting a model's internal representations. What if we allowed for explicit human training in a bridging language which is directly employed by a model? This might require us to apply principles of cognitive ergonomics to a bottleneck layer (e.g. sparsity, local structure, discreteness, Gestalt-aware symbols), so that humans could become fluent in the bridging language. A nested lattice of quantized \\\"logograms\\\" might be fitting, and young children might be particularly fit for the role of bridging the two different modes of thought. Pairs of artifacts in familiar modalities (e.g. text, images, videos) and associated translations could form the basis of the learning process, together with any discovered syntax of the emerging language.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-synthetic-interlingua-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-does-synthetic-interlingua-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-does-synthetic-interlingua-relate-to-concrete-challenges-in-alignment]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"0c89671a-7619-553a-abf0-f0cb0af6e810","fields":{"slug":"/synthetic-interlingua","title":"Synthetic Interlingua"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Physicalist Fluency\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"physicalist-fluency\"\n  }, \"Physicalist Fluency\"), mdx(\"p\", null, \"What if we try to go as close as possible to human values and bypass language? First, learn a neural interlingua by training an auxiliary model to translate across all neuroimaging modalities currently available and forcing a compact bottleneck layer. Second, condition the whole internal state of the main model to be translatable to and from the neural interlingua. This should generally ensure that human representations and human representations alone are employed by the model in its internal thought process, by constraining it to what human brains are fluent in. Third, as a slider of capability, gradually shift towards relaxing the translatability constrain by applying it to model shards only, rather than holistically. This is analogous to a team of developers working on a codebase, where each one is only responsible for a chunk of it. The codebase is still represented in human brains, but no single brain represents it.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-physicalist-fluency-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-does-physicalist-fluency-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-does-physicalist-fluency-relate-to-concrete-challenges-in-alignment]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"ca1a390a-56b3-58ed-ac5e-fcd975b63e6f","fields":{"slug":"/physicalist-fluency","title":"Physicalist Fluency"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Latent Resonators\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"latent-resonators\"\n  }, \"Latent Resonators\"), mdx(\"p\", null, \"In the context of autoregressive models, prompts are often seen as \\\"programs\\\" which specify various behaviors for the model to \\\"run\\\" next. What if we framed prompts as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"resonance chambers\"), \" of different shapes and sizes which amplify certain dynamics while dampening others? The goal would then be to devise such constructs which reliably make away with misaligned spectral components, and apply them directly to latent activations. One promising way of doing this relies on a new formalism from dynamical systems which defines an entire Boolean logic of dynamics. By taking the conjunction of whitelisted dynamics and negating blacklisted ones, we can craft and inject filters in ML models while only incurring minimal compute overhead. The layer depth of the injection site might also offer a slider between influencing the way a model \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"perceives\"), \" the world and the way it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"acts\"), \" in given circumstances.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-latent-resonators-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-latent-resonators-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-latent-resonators-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-could-latent-resonators-help-avoid-hfdt-takeover\",\n    \"title\": \"how-could-latent-resonators-help-avoid-hfdt-takeover\"\n  }, \"[[how-could-latent-resonators-help-avoid-hfdt-takeover]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"22da8d58-963c-5f3c-abaa-d6c84cbe1faa","fields":{"slug":"/latent-resonators","title":"Latent Resonators"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Benchmark Scenarios\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"benchmark-scenarios\"\n  }, \"Benchmark Scenarios\"), mdx(\"p\", null, \"Benchmark scenarios are used to evaluate proposals-in-the-making by investigating how they might concretely help avoid catastrophic outcomes.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/hfdt-takeover-scenario\",\n    \"title\": \"hfdt-takeover-scenario\"\n  }, \"[[hfdt-takeover-scenario]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"440861be-4840-5f00-9fec-7bcc45dac978","fields":{"slug":"/benchmark-scenarios","title":"Benchmark Scenarios"}}}],"inboundReferences":[]},"fields":{"slug":"/hello","title":"Home"}}},"pageContext":{"id":"571e6790-8b07-5840-82d8-0562f06bb3c9"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}