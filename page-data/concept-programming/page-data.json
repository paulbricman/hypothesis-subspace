{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/concept-programming","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Concept Programming\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"concept-programming\"\n  }, \"Concept Programming\"), mdx(\"p\", null, \"This frame is an iteration of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/abstraction-inductors\",\n    \"title\": \"abstraction-inductors\"\n  }, \"[[abstraction-inductors]]\"), \", yet it's sufficiently different from the previous version to warrant a new node. Concept programming is the process of systematically modifying the conceptual framework internalized by an ML model. To go with the analogy, concept programming languages generally include the following components:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"variables / symbols\"), \": The variable \\\"fruit\\\" is a container for the concept of fruit.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"values / concepts\"), \": The concept of fruit is contained in the \\\"fruit\\\" variable.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"assignment\"), \": Assigning a concept to a symbol is identified with heavily tweaking the ML model's ontology to reflect that.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"initialization\"), \": Initializing a new symbol is identified with creating a tabula rasa association-free entity in the model's ontology (e.g. a fresh new token).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"concept operators\"), \": Taking the conjunction of \\\"Apple\\\" and \\\"Microsoft\\\" might yield a concept of big tech company. Boolean and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://paulbricman.com/thoughtware/semantica\"\n  }, \"Semantica-like\"), \" ops are low-hanging fruit here.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"flow operators\"), \": Basic if/for/while/switch/... structures for guiding the concept program.\")), mdx(\"p\", null, \"The application idea is that using a concept program which incorporates multiple of those elements, the model's internal ontology could be systematically tweaked towards useful outcomes. For instance, this might mean forming suitable abstractions of human values, or discouraging abstractions which are at odds with those.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\",\n    \"title\": \"how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\"\n  }, \"[[how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks\",\n    \"title\": \"can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks\"\n  }, \"[[can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-variables-in-concept-programming-can-hold-more-complex-structures\",\n    \"title\": \"what-if-variables-in-concept-programming-can-hold-more-complex-structures\"\n  }, \"[[what-if-variables-in-concept-programming-can-hold-more-complex-structures]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Abstraction Inductors\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"abstraction-inductors\"\n  }, \"Abstraction Inductors\"), mdx(\"p\", null, \"Initial results from a recent interpretability technique (incidentally, my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fse.studenttheses.ub.rug.nl/27840/1/NSCv5.pdf\"\n  }, \"bachelor's thesis\"), \"), indicate that it's possible to extract parts of a transformer's internal ontology directly from latent activations, without making use of outputs at all. Analysing internal representations directly also has the benefit of making the technique modality-agnostic. Given this class of interpretability tools, what if we directly conditioned the model's ontological structure during training so as to force it to correctly learn the concept of human values in relation to other unconditioned concepts? This might either involve using a blank slate token with no other connotations or building on an existing symbol like \\\"human values\\\" and conditioning its internal representation.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-abstraction-inductors-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-abstraction-inductors-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-abstraction-inductors-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-are-useful-axes-to-describe-abstraction-inductors-along\",\n    \"title\": \"what-are-useful-axes-to-describe-abstraction-inductors-along\"\n  }, \"[[what-are-useful-axes-to-describe-abstraction-inductors-along]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"b9f495b9-5a5b-5c58-aa27-d79c7509c592","fields":{"slug":"/abstraction-inductors","title":"Abstraction Inductors"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How does concept programming relate to the natural abstraction hypothesis?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\"\n  }, \"How does concept programming relate to the natural abstraction hypothesis?\"), mdx(\"p\", null, \"In a sense, concept programming does not assume that particular abstractions which are convenient for alignment-work (e.g. human values) are inevitable to come up in any sufficiently capable system. Instead, it assumes that you need to specify procedures for building on messy interconnected high-dimensional abstractions if you want to reliably get provable overlaps between conceptual frameworks.\"), mdx(\"p\", null, \"However, there might be assumptions required for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"some\"), \" abstractions, which would be used as shared reference frames to triangulate shared positions in concept space. Having some amount of overlap seems useful, but an overlap in the target concepts wouldn't necessarily be required.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"e2974553-d53e-51ea-81e6-31b7a7b8382d","fields":{"slug":"/how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis","title":"How does concept programming relate to the natural abstraction hypothesis?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Can program correctness help provide provable guarantees on conceptual frameworks?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks\"\n  }, \"Can program correctness help provide provable guarantees on conceptual frameworks?\"), mdx(\"p\", null, \"It might be, though the grounding of concept operators in mathematical formalism might be essential for that. For instance, the boolean and linear algebra underpinnings of boolean and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://paulbricman.com/thoughtware/semantica\"\n  }, \"Semantica-like\"), \" ops might enable proofs on related properties of the concept program as a whole, or at least upper-bounds on error to be matched against thresholds based on given standards of caution.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"5719da57-738a-5955-9c0d-d9f3672d0533","fields":{"slug":"/can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks","title":"Can program correctness help provide provable guarantees on conceptual frameworks?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if variables in concept programming can hold more complex structures?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-variables-in-concept-programming-can-hold-more-complex-structures\"\n  }, \"What if variables in concept programming can hold more complex structures?\"), mdx(\"p\", null, \"In conventional programming, variables can be of more than just base types, they can be of custom types which involve more complex class-like structures. Does the concept programming metaphor preserve this property?\"), mdx(\"p\", null, \"A concept might consist in the relation between two concepts, but that would still be a base concept, except for its weird skew so that it facilitates the mapping between the two during some defined addition or join. A set of concepts might help specify a conceptual framework, so perhaps a set or list or tuple of concepts might be a sensible addition. Custom types are less easy to justify, as a set of concepts would inevitably find themselves in a certain interrelation pattern and hence lack the need for additional context provided through fields of more abstract entities.\"), mdx(\"p\", null, \"This design choice picks up on an important disanalogy between conventional programming and concept programming. In conventional programming, variables are not implicitly related other than e.g. through a specified chain of operations. In concept programming, concepts are implicitly related through their interrelations, likely expressible as ops on distributions over semantic space. \"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"21ac0454-ec65-54e5-ac31-59b9c708f4a4","fields":{"slug":"/what-if-variables-in-concept-programming-can-hold-more-complex-structures","title":"What if variables in concept programming can hold more complex structures?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Home\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"home\"\n  }, \"Home\"), mdx(\"p\", null, \"This is the root note of a (mostly) tree-shaped document which contains my work at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/D7epkkJb3CqDTYgX9/refine-an-incubator-for-conceptual-alignment-research-bets\"\n  }, \"Refine\"), \", an incubator for conceptual research on alignment hosted by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.alignmentforum.org/posts/jfq2BH5kfQqu2vYv3/we-are-conjecture-a-new-alignment-research-startup\"\n  }, \"Conjecture\"), \". I'm using this fellowship as an opportunity to explore several prosaic themes which I currently find promising, and get better at the poking process itself.\"), mdx(\"p\", null, \"Reading all depth-one theme notes should take you around five minutes \\u2014 a deliberate design choice to help you get a quick sense of what this is all about. Afterwards, I recommend switching to a depth-first traversal on whatever branch you find interesting.\"), mdx(\"p\", null, \"I'd find it extremely helpful to hear any targeted feedback you might have via the note-linked comment threads. If possible, consider phrasing it as leading questions which I can then turn into new branches from the note you're commenting on. Best viewed on desktop.\"), mdx(\"h2\", {\n    \"id\": \"themes\"\n  }, \"Themes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/ideological-inference-engines\",\n    \"title\": \"ideological-inference-engines\"\n  }, \"[[ideological-inference-engines]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/oversight-leagues\",\n    \"title\": \"oversight-leagues\"\n  }, \"[[oversight-leagues]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/concept-programming\",\n    \"title\": \"concept-programming\"\n  }, \"[[concept-programming]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/latent-resonators\",\n    \"title\": \"latent-resonators\"\n  }, \"[[latent-resonators]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/synthetic-interlingua\",\n    \"title\": \"synthetic-interlingua\"\n  }, \"[[synthetic-interlingua]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/physicalist-fluency\",\n    \"title\": \"physicalist-fluency\"\n  }, \"[[physicalist-fluency]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/symbiont-sandboxes\",\n    \"title\": \"symbiont-sandboxes\"\n  }, \"[[symbiont-sandboxes]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/differentiable-cosmogonies\",\n    \"title\": \"differentiable-cosmogonies\"\n  }, \"[[differentiable-cosmogonies]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"appendix\"\n  }, \"Appendix\"), mdx(\"p\", null, \"Mostly meta-science considerations as opposed to the object-level ideas:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/benchmark-scenarios\",\n    \"title\": \"benchmark-scenarios\"\n  }, \"[[benchmark-scenarios]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Process\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Artifact\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Background\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Next Steps\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Refiner Blogroll\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Acknowledgements\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"571e6790-8b07-5840-82d8-0562f06bb3c9","fields":{"slug":"/hello","title":"Home"}}}]},"fields":{"slug":"/concept-programming","title":"Concept Programming"}}},"pageContext":{"id":"c0f9eba5-fb3f-5a6a-8ef3-df41c5e1a4f9"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}