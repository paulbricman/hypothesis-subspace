{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How does concept programming relate to the natural abstraction hypothesis?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\"\n  }, \"How does concept programming relate to the natural abstraction hypothesis?\"), mdx(\"p\", null, \"In a sense, concept programming does not assume that particular abstractions which are convenient for alignment-work (e.g. human values) are inevitable to come up in any sufficiently capable system. Instead, it assumes that you need to specify procedures for building on messy interconnected high-dimensional abstractions if you want to reliably get provable overlaps between conceptual frameworks.\"), mdx(\"p\", null, \"However, there might be assumptions required for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"some\"), \" abstractions, which would be used as shared reference frames to triangulate shared positions in concept space. Having some amount of overlap seems useful, but an overlap in the target concepts wouldn't necessarily be required.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Concept Programming\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"concept-programming\"\n  }, \"Concept Programming\"), mdx(\"p\", null, \"This frame is an iteration of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/abstraction-inductors\",\n    \"title\": \"abstraction-inductors\"\n  }, \"[[abstraction-inductors]]\"), \", yet it's sufficiently different from the previous version to warrant a new node. Concept programming is the process of systematically modifying the conceptual framework internalized by an ML model. To go with the analogy, concept programming languages generally include the following components:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"variables / symbols\"), \": The variable \\\"fruit\\\" is a container for the concept of fruit.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"values / concepts\"), \": The concept of fruit is contained in the \\\"fruit\\\" variable.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"assignment\"), \": Assigning a concept to a symbol is identified with heavily tweaking the ML model's ontology to reflect that.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"initialization\"), \": Initializing a new symbol is identified with creating a tabula rasa association-free entity in the model's ontology (e.g. a fresh new token).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"concept operators\"), \": Taking the conjunction of \\\"Apple\\\" and \\\"Microsoft\\\" might yield a concept of big tech company. Boolean and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://paulbricman.com/thoughtware/semantica\"\n  }, \"Semantica-like\"), \" ops are low-hanging fruit here.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"flow operators\"), \": Basic if/for/while/switch/... structures for guiding the concept program.\")), mdx(\"p\", null, \"The application idea is that using a concept program which incorporates multiple of those elements, the model's internal ontology could be systematically tweaked towards useful outcomes. For instance, this might mean forming suitable abstractions of human values, or discouraging abstractions which are at odds with those.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\",\n    \"title\": \"how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis\"\n  }, \"[[how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks\",\n    \"title\": \"can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks\"\n  }, \"[[can-program-correctness-help-provide-provable-guarantees-on-conceptual-frameworks]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-variables-in-concept-programming-can-hold-more-complex-structures\",\n    \"title\": \"what-if-variables-in-concept-programming-can-hold-more-complex-structures\"\n  }, \"[[what-if-variables-in-concept-programming-can-hold-more-complex-structures]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"c0f9eba5-fb3f-5a6a-8ef3-df41c5e1a4f9","fields":{"slug":"/concept-programming","title":"Concept Programming"}}}]},"fields":{"slug":"/how-does-concept-programming-relate-to-the-natural-abstraction-hypothesis","title":"How does concept programming relate to the natural abstraction hypothesis?"}}},"pageContext":{"id":"e2974553-d53e-51ea-81e6-31b7a7b8382d"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}