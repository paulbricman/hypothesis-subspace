{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/how-do-ideological-inference-engines-resist-gaming","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How do ideological inference engines resist gaming?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-do-ideological-inference-engines-resist-gaming\"\n  }, \"How do ideological inference engines resist gaming?\"), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/what-if-alex-games-the-expanding-charter\",\n    \"title\": \"what-if-alex-games-the-expanding-charter\"\n  }, \"[[what-if-alex-games-the-expanding-charter]]\"), \", an AGI tries to game an IIE-like system. What defensive mechanism does IIE in general have against such behavior?\"), mdx(\"p\", null, \"First, there's the line of work involving making the knowledge base and entailment verifiers itself hard to game, by e.g. redundantly encoding human values in different formulations. This way of thinking frames IIEs as means of implementing the True Name of human values, where any attempt to actually perform well on its objective, including gaming attempts, would inevitably still be aligned due to the objective's robustness.\"), mdx(\"p\", null, \"Second, there's the line of work which involves discouraging gaming attempts through (infinite) penalties in term of reward. Penalties might either need to be infinitely aversive or some induced myopia might be necessary to help avoid the agent's consequentialist frenzy, similar to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/what-if-alex-hacks-the-deontic-array\",\n    \"title\": \"what-if-alex-hacks-the-deontic-array\"\n  }, \"[[what-if-alex-hacks-the-deontic-array]]\"), \". Adversarially eliciting gaming before penalizing the agent in order to condition it to avoid this behavior faces similar issues like ones brought up by the original \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hfdt-takeover\",\n    \"title\": \"hfdt-takeover\"\n  }, \"[[hfdt-takeover]]\"), \" article.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex games the expanding charter?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-games-the-expanding-charter\"\n  }, \"What if Alex games the expanding charter?\"), mdx(\"p\", null, \"With its excellent situational awareness, Alex might likely be aware of the specifics of the deontic array and its current charter (e.g. by having an internal representation of it). This begs the question of Alex gaming the charter as it might game human feedback.\"), mdx(\"p\", null, \"If the multi-modal evaluator is Alex itself, it might cleverly adapt to make a specific charter principle relatively more likely to follow than its anti-charter counterpart, while still ranking dangerous courses of action (and non-text sequences in general) way above both of those continuations. It could also just make specific charter principles more likely in general (including when following from its actions). It is uncertain whether it would lead to more aligned behavior (as it would grow more fluent in morality in an attempt to game the system) or wishful thinking (i.e. convincing itself moral principles underlie actually-immoral actions).\"), mdx(\"p\", null, \"If the multi-modal evaluator is a past version of Alex, it might not initially be able to game it as easily. The evaluator at a given step might lack the bias towards making a specific situation seem better than it really is (e.g. by blindly pretending an actually-immoral action is rooted in moral principles). However, given its assumed self-awareness, Alex might reason that morally corrupting its current self might later help it achieve higher reward when the corrupted version is selected as an evaluator, even if it would miss out on the short-term perks of its conformism.\"), mdx(\"p\", null, \"If the multi-modal evaluator is a completely separate Gato/Flamingo-like model, Alex might find it difficult to game the deontic array by morally corrupting itself as the evaluator. However, it might narrow in on quirks of those possibly-frozen models and pick courses of actions which seem extremely moral, despite not truly being so. For instance, perhaps this specific term has a weaker association with this specific action. However, this is where the targeted red teaming would come into play, helping systematically eliminate blindspots of the evaluator. Still, this might not be enough.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"7e9621b0-269d-5ff7-b8ac-32458c40ce1e","fields":{"slug":"/what-if-alex-games-the-expanding-charter","title":"What if Alex games the expanding charter?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex hacks the deontic array?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-hacks-the-deontic-array\"\n  }, \"What if Alex hacks the deontic array?\"), mdx(\"p\", null, \"The deontic array is assumed to be running on some server and offering Alex feedback on its actions. Given its situational awareness, it might be able to reason about faking its \\\"reports\\\" prior to evaluation, or overwriting the reward entirely.\"), mdx(\"p\", null, \"Without any modifications, deontic arrays might obviate this concern by instilling an aversion towards planning out immoral actions. Those might nudge Alex away from considering this type of tampering in the first place. However, the potential payoff might be immense, pushing it to temporarily step over its drive towards morality in an episode of frenetic consequentialism.\"), mdx(\"p\", null, \"Other reactions to this concern might require additional technical tweaks. For instance, as the evaluation is reliably deterministic (as opposed to direct human feedback), it can run in multiple different sandbox environments, before various inter-annotator agreement schemes would be employed to pin down compromised hosts. Such partial compromise might trigger a killswitch (which itself might be faulty). However, this scheme is still vulnerable to situations in which Alex compromises all hosts at the same time, leaving out no evidence of lack of consensus and covering its tracks.\"), mdx(\"p\", null, \"Yet another reaction to this concern consists in rewarding the process of being rewarded via the original evaluation pipeline in particular. One of the terminal goals on which Alex would be conditioned could be to allow itself to be evaluated in the original fashion. This line of reasoning was inspired by Tammy. Perhaps it would be rewarded for helping the evaluator follow each step of its pipeline (e.g. each line of code, each machine code op, etc.). However, the same concern resurfaces. Alex might just swallow short-term penalties triggered by tampering in light of potentially huge consequentialist payoffs. Perhaps force Alex to be somewhat myopic to avoid this?\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"189bf4b0-34a2-518f-b063-40bdd838861a","fields":{"slug":"/what-if-alex-hacks-the-deontic-array","title":"What if Alex hacks the deontic array?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Ideological Inference Engines\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ideological-inference-engines\"\n  }, \"Ideological Inference Engines\"), mdx(\"p\", null, \"Ideological inference engines are at the same time a generalization and merger of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", connecting the two previous approaches into a shared framework while combining their strengths. In general, this framework relies on expanding an initial knowledge base meant to capture human values using LLMs and promoting courses of action which are compatible with the resulting expansion. Every ideological inference engine has the following ingredients:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"knowledge base\"), \" (KB): The initial seed aiming to capture human values. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this was a fixed-length charter containing normative principles. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was a position in a debate between competing memeplexes. In general, the knowledge based is a finite set of sequences. Those sequences can be propositional (e.g. normative principles), but might also be behavioral (e.g. state-action trajectories).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"inference mechanism\"), \" (\\u22A2): The procedure for systematically expanding the knowledge base. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this procedure was based on a mix of counterfactual cross-validation and targeted red teaming. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was based on investigating multiple memetic phylogenies in a setting of competitive pressure. The inference mechanism might also be a naive forward-chaining procedure, inspired by \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", but without competitive pressures (i.e. just incentives for internal consistency).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"entailment verifier\"), \" (\\u22A8): Given an (expanded) knowledge base, the procedure for approving different courses of action. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was based on Overton probing of textual content or textual descriptions of non-textual content. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this was based on counterfactual likelihood (i.e. checking whether principles where more likely to follow than negated principles). Similarly to previous ingredients, the generalized framing also accepts a wider variety of approches for verifiers.\")), mdx(\"p\", null, \"IIEs relate to GOFAI inference engines in several intuitive ways. For instance, both roughly rely on expanding a knowledge base using an inference engine and then using the expanded knowledge base to verify a new item. Additionally, they both run into similar issues. How to handle a combinatorial explosion of the knowledge base when relying on forward-chaining in complex domains? How to handle infinite loops if working with backward-chaining (i.e. reasoning backwards)? Solutions identified in GOFAI might help alleviate analogous ones in IIE.\"), mdx(\"p\", null, \"However, there are important conceptual differences between the two. For one, the whole set of clean inference rules discussed in GOFAI settings (e.g. Modus Ponents, Modus Tolens, etc.) are imperfectly handled by LLMs in the current context. Inevitably, the messiness of language as a representation medium (though a behavioral KB might also work), combined with the messiness of human values expressed in said medium make for a fuzzier and more opaque inference engine. The KB only contains true atoms, while LLMs handle all the implicit rules to relate them to new ones, in a somewhat awkward mix-up of the meanings of \\\"model\\\" and \\\"knowledge base\\\" across the two settings. Still, the similarities and structure provided by the framework seem compelling.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-is-the-relation-between-the-knowledge-base-and-approved-actions\",\n    \"title\": \"what-is-the-relation-between-the-knowledge-base-and-approved-actions\"\n  }, \"[[what-is-the-relation-between-the-knowledge-base-and-approved-actions]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-would-backward-chaining-work-in-ideological-inference-engines\",\n    \"title\": \"how-would-backward-chaining-work-in-ideological-inference-engines\"\n  }, \"[[how-would-backward-chaining-work-in-ideological-inference-engines]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-the-inherited-field-theory-apply\",\n    \"title\": \"how-does-the-inherited-field-theory-apply\"\n  }, \"[[how-does-the-inherited-field-theory-apply]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-ideological-inference-engines-resist-gaming\",\n    \"title\": \"how-do-ideological-inference-engines-resist-gaming\"\n  }, \"[[how-do-ideological-inference-engines-resist-gaming]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"2fc92a94-4cc4-5fb3-9c8a-ddef2f1166c7","fields":{"slug":"/ideological-inference-engines","title":"Ideological Inference Engines"}}}]},"fields":{"slug":"/how-do-ideological-inference-engines-resist-gaming","title":"How do ideological inference engines resist gaming?"}}},"pageContext":{"id":"360051e6-0aa1-5f25-933a-12bbbe004694"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}