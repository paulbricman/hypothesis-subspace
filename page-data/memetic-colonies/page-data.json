{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/memetic-colonies","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Memetic Colonies\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"memetic-colonies\"\n  }, \"Memetic Colonies\"), mdx(\"p\", null, \"Based on a new formalism from argumentation theory, we might be able to turn large language models into Petri dishes for cultivating belief systems. In such a memetic pressure cooker, a host of belief systems would be incentivized to generally maintain internal consistency while systematically undermining each other. In this framework, we could develop specialized \\\"lab equipment\\\" to help us (1) extrapolate belief systems, (2) accelerate conceptual research, and (3) synthesize a memetic variant of the GPU-burner. For instance, an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Overton_window\"\n  }, \"Overton\"), \" probe could be used in tandem with a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pubmed.ncbi.nlm.nih.gov/26790344/\"\n  }, \"Gould\"), \" fork to estimate the future compatibility of a belief system with a given statement across a large number of counterfactual phylogenies. Alternatively, a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Paradigm_shift\"\n  }, \"Kuhn\"), \" seismograph could help pinpoint major shifts in worldview as places to search for underlying ideological invariants.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/are-memetic-colonies-faithful-models-of-actual-memetic-dynamics\",\n    \"title\": \"are-memetic-colonies-faithful-models-of-actual-memetic-dynamics\"\n  }, \"[[are-memetic-colonies-faithful-models-of-actual-memetic-dynamics]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-can-moral-epistemology-taxonomies-organize-robust-objectives\",\n    \"title\": \"how-can-moral-epistemology-taxonomies-organize-robust-objectives\"\n  }, \"[[how-can-moral-epistemology-taxonomies-organize-robust-objectives]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How do memetic colonies relate to concrete challenges in alignment?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment\"\n  }, \"How do memetic colonies relate to concrete challenges in alignment?\"), mdx(\"p\", null, \"Memetic colonies might help us define an optimization target which captures our normative beliefs while being robust to both unprecedented situations (e.g. novel capabilities) and paradigm shifts (e.g. a major future change in the seed normative framework). At the same time, they might help alleviate acausal blackmail by penalizing the fitness of memeplexes which are compatible with such thought patterns. In this, memetic colonies attempt to implement a mechanism for coherent extrapolation of volition. In different terms, memetic colonies aim to implement the True Name of a given normative framework through memetic modeling.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"4536f45d-1728-59b7-9a5b-91e104570d4f","fields":{"slug":"/how-do-memetic-colonies-relate-to-concrete-challenges-in-alignment","title":"How do memetic colonies relate to concrete challenges in alignment?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Are memetic colonies faithful models of actual memetic dynamics?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"are-memetic-colonies-faithful-models-of-actual-memetic-dynamics\"\n  }, \"Are memetic colonies faithful models of actual memetic dynamics?\"), mdx(\"p\", null, \"In memetic colonies, multiple belief systems are pressured to exhibit internal coherence and ruthlessly undermine each other. Over time, the competing memeplexes exhibit drift. However, real-world memes are not constrained to an hermetically sealed bubble of causality, with messy psychological, sociological, economical, etc. influences constantly acting on them. Given this, it wouldn't be realistic to attempt to put together a perfect model of memetics with infinitesimal uncertainty.\"), mdx(\"p\", null, \"That said, despite being unable to craft a perfect model, we might still be able to craft a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useful\"), \" model of memetics to help target our AGI. In the best case scenario, such a model would provide well-calibrated measures of uncertainty in its outputs (e.g. confidence intervals) and prove relatively on track with empirically observed dynamics (e.g. in historical data, in lab environments, etc.).\"), mdx(\"p\", null, \"Additionally, we might agree on what makes a memetic phylogeny realistic (e.g. competitiveness), and go forward with a model which at least implements those features, despite exhibiting growing uncertainty with respect to the haphazard timeline we happen to find ourselves in. This reminds me of the contrast between existence and uniqueness proofs in maths, where the very existence of plausible memetic trajectories (e.g. ones where each tiny shift in worldview is formally plausible) being better than nothing despite not having a uniqueness proof pointing at one golden timeline in particular.\"), mdx(\"p\", null, \"Additionally, memetic colonies relax the ambition of predicting exact memes by enabling us to study the overall compatibility of memeplexes with certain ideas (i.e. via Overton probes). There might be multiple memeplexes endorsing a belief for different reasons, lowering the bar for at least figuring out the general properties of actual memetic development.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"53a87802-2138-5f09-b04c-3010d6fccf85","fields":{"slug":"/are-memetic-colonies-faithful-models-of-actual-memetic-dynamics","title":"Are memetic colonies faithful models of actual memetic dynamics?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How can moral epistemology taxonomies organize robust objectives?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-can-moral-epistemology-taxonomies-organize-robust-objectives\"\n  }, \"How can moral epistemology taxonomies organize robust objectives?\"), mdx(\"p\", null, \"Many alignment proposals attempt to capture the True Name of human value as a target to aim optimizers at. However, any attempt of implementing such proposals would inevitably carry over assumptions of moral epistemology and moral ontology: how is knowledge about morality gained and how is it shaped.\"), mdx(\"p\", null, \"Moral ontology considerations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"universalism\"), \": There's a universally-applicable normative framework out there. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" generally buy into this. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" partially buy into this, because although the seed memeplex is fixed, it is different from the forecasted ones.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"relativism\"), \": To each their own, normative frameworks are grounded in cultures or individuals. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" might extend into this by cultivating multiple seed memeplexes. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" might move towards this stance through hierarchical charters spanning a global-to-local spectrum.\")), mdx(\"p\", null, \"Moral epistemology considerations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rationalism\"), \": Moral truth can be attained by rational deliberation or reflection alone. The two True Name-like proposals currently on this website don't align with this stance that much.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"empiricism\"), \": Moral truth is attained through observation. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" are the closest to this stance, as they involves observing memetic simulations. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" feel somewhat in the middle, as the counterfaction cross-validation scheme has a large statistical component, though the way the charter is obtained is not specified.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2275dc5e-49a3-554f-9123-c8f79d08abe4","fields":{"slug":"/how-can-moral-epistemology-taxonomies-organize-robust-objectives","title":"How can moral epistemology taxonomies organize robust objectives?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How can moral epistemology taxonomies organize robust objectives?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-can-moral-epistemology-taxonomies-organize-robust-objectives\"\n  }, \"How can moral epistemology taxonomies organize robust objectives?\"), mdx(\"p\", null, \"Many alignment proposals attempt to capture the True Name of human value as a target to aim optimizers at. However, any attempt of implementing such proposals would inevitably carry over assumptions of moral epistemology and moral ontology: how is knowledge about morality gained and how is it shaped.\"), mdx(\"p\", null, \"Moral ontology considerations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"universalism\"), \": There's a universally-applicable normative framework out there. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" generally buy into this. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" partially buy into this, because although the seed memeplex is fixed, it is different from the forecasted ones.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"relativism\"), \": To each their own, normative frameworks are grounded in cultures or individuals. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" might extend into this by cultivating multiple seed memeplexes. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" might move towards this stance through hierarchical charters spanning a global-to-local spectrum.\")), mdx(\"p\", null, \"Moral epistemology considerations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rationalism\"), \": Moral truth can be attained by rational deliberation or reflection alone. The two True Name-like proposals currently on this website don't align with this stance that much.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(moral) \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"empiricism\"), \": Moral truth is attained through observation. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" are the closest to this stance, as they involves observing memetic simulations. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \" feel somewhat in the middle, as the counterfaction cross-validation scheme has a large statistical component, though the way the charter is obtained is not specified.\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"2275dc5e-49a3-554f-9123-c8f79d08abe4","fields":{"slug":"/how-can-moral-epistemology-taxonomies-organize-robust-objectives","title":"How can moral epistemology taxonomies organize robust objectives?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How would backward-chaining work in ideological inference engines?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-would-backward-chaining-work-in-ideological-inference-engines\"\n  }, \"How would backward-chaining work in ideological inference engines?\"), mdx(\"p\", null, \"The initial inference mechanisms considered in IIE based on the previous merged frames feel like forward-chaining. The target proposition or behavior has no say in the way the knowledge base expands in those original means of expansion. However, it might be useful to guide the expansion towards regions which appear relevant to dealing with the new items to be verified.\"), mdx(\"p\", null, \"For instance, instead of targeting the charter expansion towards normative regions which are not redundantly accounted for by other principles, it might be interesting to partially guide the expansion towards normative regions relevant to the item to be verified. For instance, if most principles in the charter (i.e. most items in the knowledge base) are unrelated to the item to be verified, it might be sensible to focus on expanding on ones which are a bit related. Of course, there might be a round-about way of getting to relevant propositions, echoing the shortcomings of heuristics in general.\"), mdx(\"p\", null, \"As another example, one might imagine incentivizing the competing memeplexes in a debate (one of which is the one to be extrapolated), to align with the item to be verified. Due to competitive pressures, not all will do, providing at the same time a heuristic towards expanding on topic and an entailment verification mechanism (i.e. checking if the main memeplex gets to buy into the item to be verified).\"), mdx(\"p\", null, \"As another example, one might imagine injecting the verification target into the memeplex to be extrapolated, and seeing how it reacts. If it radically diverges to maintain consistency, then it might not be compatible. If it stays on track, it might be. However, this feels more like an active version of Overton probing, rather than a search heuristic. Though it still forces the debate towards the topic. What if you'd inject the verification target in one timeline and its negation in other and measured which one diverged least, a mix between the original \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \".\"), mdx(\"p\", null, \"As mentioned before, some approaches to backward-chaining feel like complementing the inference mechanism (e.g. nudging charter expansion to be on topic), while some others feel like implementing new entailment verifiers (e.g. injecting the verification target and observing memetic developments). They might still be decoupled into inference mechanism and entailment verifier, even if they go together and are coupled. If they're not truly coupled they might even yield generative effect.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-much-could-expansion-heuristics-help\",\n    \"title\": \"how-much-could-expansion-heuristics-help\"\n  }, \"[[how-much-could-expansion-heuristics-help]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"2e808b87-cd25-58bd-aac3-13bde6dce02c","fields":{"slug":"/how-would-backward-chaining-work-in-ideological-inference-engines","title":"How would backward-chaining work in ideological inference engines?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Ideological Inference Engines\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ideological-inference-engines\"\n  }, \"Ideological Inference Engines\"), mdx(\"p\", null, \"Ideological inference engines are at the same time a generalization and merger of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", connecting the two previous approaches into a shared framework while combining their strengths. In general, this framework relies on expanding an initial knowledge base meant to capture human values using LLMs and promoting courses of action which are compatible with the resulting expansion. Every ideological inference engine has the following ingredients:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"knowledge base\"), \" (KB): The initial seed aiming to capture human values. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this was a fixed-length charter containing normative principles. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was a position in a debate between competing memeplexes. In general, the knowledge based is a finite set of sequences. Those sequences can be propositional (e.g. normative principles), but might also be behavioral (e.g. state-action trajectories).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"inference mechanism\"), \" (\\u22A2): The procedure for systematically expanding the knowledge base. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this procedure was based on a mix of counterfactual cross-validation and targeted red teaming. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was based on investigating multiple memetic phylogenies in a setting of competitive pressure. The inference mechanism might also be a naive forward-chaining procedure, inspired by \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", but without competitive pressures (i.e. just incentives for internal consistency).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"entailment verifier\"), \" (\\u22A8): Given an (expanded) knowledge base, the procedure for approving different courses of action. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/memetic-colonies\",\n    \"title\": \"memetic-colonies\"\n  }, \"[[memetic-colonies]]\"), \", this was based on Overton probing of textual content or textual descriptions of non-textual content. In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/deontic-arrays\",\n    \"title\": \"deontic-arrays\"\n  }, \"[[deontic-arrays]]\"), \", this was based on counterfactual likelihood (i.e. checking whether principles where more likely to follow than negated principles). Similarly to previous ingredients, the generalized framing also accepts a wider variety of approches for verifiers.\")), mdx(\"p\", null, \"IIEs relate to GOFAI inference engines in several intuitive ways. For instance, both roughly rely on expanding a knowledge base using an inference engine and then using the expanded knowledge base to verify a new item. Additionally, they both run into similar issues. How to handle a combinatorial explosion of the knowledge base when relying on forward-chaining in complex domains? How to handle infinite loops if working with backward-chaining (i.e. reasoning backwards)? Solutions identified in GOFAI might help alleviate analogous ones in IIE.\"), mdx(\"p\", null, \"However, there are important conceptual differences between the two. For one, the whole set of clean inference rules discussed in GOFAI settings (e.g. Modus Ponents, Modus Tolens, etc.) are imperfectly handled by LLMs in the current context. Inevitably, the messiness of language as a representation medium (though a behavioral KB might also work), combined with the messiness of human values expressed in said medium make for a fuzzier and more opaque inference engine. The KB only contains true atoms, while LLMs handle all the implicit rules to relate them to new ones, in a somewhat awkward mix-up of the meanings of \\\"model\\\" and \\\"knowledge base\\\" across the two settings. Still, the similarities and structure provided by the framework seem compelling.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-is-the-relation-between-the-knowledge-base-and-approved-actions\",\n    \"title\": \"what-is-the-relation-between-the-knowledge-base-and-approved-actions\"\n  }, \"[[what-is-the-relation-between-the-knowledge-base-and-approved-actions]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-would-backward-chaining-work-in-ideological-inference-engines\",\n    \"title\": \"how-would-backward-chaining-work-in-ideological-inference-engines\"\n  }, \"[[how-would-backward-chaining-work-in-ideological-inference-engines]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-does-the-inherited-field-theory-apply\",\n    \"title\": \"how-does-the-inherited-field-theory-apply\"\n  }, \"[[how-does-the-inherited-field-theory-apply]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-ideological-inference-engines-resist-gaming\",\n    \"title\": \"how-do-ideological-inference-engines-resist-gaming\"\n  }, \"[[how-do-ideological-inference-engines-resist-gaming]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"2fc92a94-4cc4-5fb3-9c8a-ddef2f1166c7","fields":{"slug":"/ideological-inference-engines","title":"Ideological Inference Engines"}}}]},"fields":{"slug":"/memetic-colonies","title":"Memetic Colonies"}}},"pageContext":{"id":"9b714b07-8533-5941-91a9-3181f4836c3e"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}