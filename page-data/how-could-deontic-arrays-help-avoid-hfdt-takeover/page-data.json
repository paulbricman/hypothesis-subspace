{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/how-could-deontic-arrays-help-avoid-hfdt-takeover","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How could deontic arrays help avoid HFDT takeover?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"how-could-deontic-arrays-help-avoid-hfdt-takeover\"\n  }, \"How could deontic arrays help avoid HFDT takeover?\"), mdx(\"p\", null, \"Deontic arrays would be applied to the model being trained in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hfdt-takeover-scenario\",\n    \"title\": \"hfdt-takeover-scenario\"\n  }, \"[[hfdt-takeover-scenario]]\"), \" as an additional component of the optimization target. The approach would be applicable to all training regimes present in the scenario: self-supervised, supervised, and reinforcement learning.\"), mdx(\"p\", null, \"In its basic form, the technique would be employed as follows. First, a large charter of normative principles expressed in written language would be collected from various sources. Those should contain huge amounts of redundancy (i.e. expressing the same principle in various formulations). The charter does not have to be internally consistent -- principles are allowed to occasionally clash.\"), mdx(\"p\", null, \"Second, the charter would (automatically) be converted into an anti-charter which contains a negated version of each principle mentioned in the original charter.\"), mdx(\"p\", null, \"Third, the two charters would be treated as collections of token sequences (i.e. sequences of words/subwords/characters). Given those two sequence sets, the model being trained would be incentived to output action sequences from which \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the original principles are more likely to follow compared to the negated versions\"), \". This requires a multi-modal model (e.g. the same model, a separate one, a past copy, etc.) to turn the action history and principles into a numerical reward signal. This signal would then join the main reward to form a final objective through an aggregation scheme (e.g. linear combination, geometric mean, etc.).\"), mdx(\"p\", null, \"Fourth, the charter (and anti-charter) would be extended in parallel to overspecify the desired normative framework in an attempt to e.g. avoid quibbling over the specific letter of the law. The vanilla version of deontic arrays relies on what could be called \\\"counterfactual cross-validation,\\\" which goes as follows. If in a completely sandboxed environment with only one output bit we temporarily discard part of the charter, is the model prevented from violating those anyways thanks to the remaining principles redundantly making up for them? If not, target external red teaming efforts to automatically patch up that brittle part of the normative framework. Potentially discount older principles to allow some drift, in a style loosely related to CEV by memetic colonies.\"), mdx(\"p\", null, \"As a bonus, deontic arrays might help instill an aversion towards taking decisions which might then in turn lead to charter-violating actions later on, especially in a reinforcement learning regime. The model might grow to value actions which don't place it in morally ambiguous situations in the future, giving itself less opportunity to err.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-charter-grows-unwieldy-in-size\",\n    \"title\": \"what-if-the-charter-grows-unwieldy-in-size\"\n  }, \"[[what-if-the-charter-grows-unwieldy-in-size]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework\",\n    \"title\": \"what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework\"\n  }, \"[[what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-games-the-expanding-charter\",\n    \"title\": \"what-if-alex-games-the-expanding-charter\"\n  }, \"[[what-if-alex-games-the-expanding-charter]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-alex-hacks-the-deontic-array\",\n    \"title\": \"what-if-alex-hacks-the-deontic-array\"\n  }, \"[[what-if-alex-hacks-the-deontic-array]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-moral-absolutism-is-misguided\",\n    \"title\": \"what-if-moral-absolutism-is-misguided\"\n  }, \"[[what-if-moral-absolutism-is-misguided]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-immoral-means-are-required-for-moral-ends\",\n    \"title\": \"what-if-immoral-means-are-required-for-moral-ends\"\n  }, \"[[what-if-immoral-means-are-required-for-moral-ends]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/what-if-the-two-component-rewards-are-unstable\",\n    \"title\": \"what-if-the-two-component-rewards-are-unstable\"\n  }, \"[[what-if-the-two-component-rewards-are-unstable]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"HFDT Takeover Scenario\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"hfdt-takeover-scenario\"\n  }, \"HFDT Takeover Scenario\"), mdx(\"p\", null, \"A multi-modal autoregressive model called Alex is designed by a company called Magma to make major contributions to science using common peripherals as input and output (e.g. visual input via screen, action outputs via mouse and keyboard). It is trained using a mix of supervised, self-supervised, and reinforcement learning. While (self-)supervised learning is used to bootstrap a world model and a naive policy (by imitating humans), the main learning signal comes from human feedback on diverse tasks offered as reward during RL.\"), mdx(\"p\", null, \"Naive safety efforts make Alex appear safe during day-to-day lab situations, prompting Magma to deploy Alex into the world, connecting it directly to the Internet (rather than granting it access to an Internet dump). Alex then uses its high situational awareness to maneuver itself into a position which allows it to reliably obtain high reward (e.g. by forcing humans into that, by hacking the reward pipeline and preventing humans from intervening, etc.). The end.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.alignmentforum.org/posts/pRkFkzwKZ2zfa3R6H/without-specific-countermeasures-the-easiest-path-to\"\n  }, \"original\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"97eb243b-3cf8-596c-aa7a-3b2c37520eba","fields":{"slug":"/hfdt-takeover-scenario","title":"HFDT Takeover Scenario"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if the charter grows unwieldy in size?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-the-charter-grows-unwieldy-in-size\"\n  }, \"What if the charter grows unwieldy in size?\"), mdx(\"p\", null, \"Automatically extending the charter might lead to a large charter later on. As the \\\"resolution\\\" of the patchwork normative framework grows (i.e. many specific principles), the amount of compute necessary to evaluate the suitability of different actions based on the charter might also grow, potentially limiting capabilities in an economically-undesirable way.\"), mdx(\"p\", null, \"However, assuming the deontic array really is effective in a fundamental way, having a control knob over the intensity of its constraints might be a feature, not a bug. One might imagine a deployment strategy where the amount of compute invested in deontic prudence would be loosely proportional to the model's capabilities and scale at any given moment. Only a model at a certain capability level might be able to game a given charter, so it seems sensible to invest the associated compute then, perhaps somewhat conservatively early.\"), mdx(\"p\", null, \"In a sense, the alignment tax would be framed as a percentage commission of the whole project, growing over time in an absolute sense but remaining relatively tiny.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"719be668-b997-57ad-beca-9822e45ca950","fields":{"slug":"/what-if-the-charter-grows-unwieldy-in-size","title":"What if the charter grows unwieldy in size?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if the seed charter misses critical parts of the implicit normative framework?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework\"\n  }, \"What if the seed charter misses critical parts of the implicit normative framework?\"), mdx(\"p\", null, \"The seed charter would contain a finite set of normative principles as data points describing the shape of an implicit normative framework. However, the authors of the seed charter might unwillingly miss certain important parts when trying to paint the picture of their values. Those slippages might be caused by the authors not being consciously aware of some of their normative principles. Alternatively, they might be caused by the authors underestimating the importance of certain principles (e.g. by taking them as obvious to advanced cognitive systems).\"), mdx(\"p\", null, \"In a sense, counterfactual cross-validation followed by targeted red teaming resembles interpolation of values rather than extrapolation, because the charter would be automatically extended to patch up the seed principles, rather than posit qualitatively novel ones. In contrast, memetic colonies in their vanilla form target an extrapolation mechanism. Those two themes might cross-polinate to account for this seeming flaw of deontic arrays.\"), mdx(\"p\", null, \"That said, a sufficiently broad seed charter might still capture the vast majority of the implicit normative framework, requiring only interpolation to refine. One somewhat brittle argument here relies on human law being relatively effective in orchestrating society, while in large part relying on expanding and applying previous ideals to new situations.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"cd92e3a9-f7da-547f-897b-048f24a1124d","fields":{"slug":"/what-if-the-seed-charter-misses-critical-parts-of-the-implicit-normative-framework","title":"What if the seed charter misses critical parts of the implicit normative framework?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex games the expanding charter?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-games-the-expanding-charter\"\n  }, \"What if Alex games the expanding charter?\"), mdx(\"p\", null, \"With its excellent situational awareness, Alex might likely be aware of the specifics of the deontic array and its current charter (e.g. by having an internal representation of it). This begs the question of Alex gaming the charter as it might game human feedback.\"), mdx(\"p\", null, \"If the multi-modal evaluator is Alex itself, it might cleverly adapt to make a specific charter principle relatively more likely to follow than its anti-charter counterpart, while still ranking dangerous courses of action (and non-text sequences in general) way above both of those continuations. It could also just make specific charter principles more likely in general (including when following from its actions). It is uncertain whether it would lead to more aligned behavior (as it would grow more fluent in morality in an attempt to game the system) or wishful thinking (i.e. convincing itself moral principles underlie actually-immoral actions).\"), mdx(\"p\", null, \"If the multi-modal evaluator is a past version of Alex, it might not initially be able to game it as easily. The evaluator at a given step might lack the bias towards making a specific situation seem better than it really is (e.g. by blindly pretending an actually-immoral action is rooted in moral principles). However, given its assumed self-awareness, Alex might reason that morally corrupting its current self might later help it achieve higher reward when the corrupted version is selected as an evaluator, even if it would miss out on the short-term perks of its conformism.\"), mdx(\"p\", null, \"If the multi-modal evaluator is a completely separate Gato/Flamingo-like model, Alex might find it difficult to game the deontic array by morally corrupting itself as the evaluator. However, it might narrow in on quirks of those possibly-frozen models and pick courses of actions which seem extremely moral, despite not truly being so. For instance, perhaps this specific term has a weaker association with this specific action. However, this is where the targeted red teaming would come into play, helping systematically eliminate blindspots of the evaluator. Still, this might not be enough.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"7e9621b0-269d-5ff7-b8ac-32458c40ce1e","fields":{"slug":"/what-if-alex-games-the-expanding-charter","title":"What if Alex games the expanding charter?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if Alex hacks the deontic array?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-alex-hacks-the-deontic-array\"\n  }, \"What if Alex hacks the deontic array?\"), mdx(\"p\", null, \"The deontic array is assumed to be running on some server and offering Alex feedback on its actions. Given its situational awareness, it might be able to reason about faking its \\\"reports\\\" prior to evaluation, or overwriting the reward entirely.\"), mdx(\"p\", null, \"Without any modifications, deontic arrays might obviate this concern by instilling an aversion towards planning out immoral actions. Those might nudge Alex away from considering this type of tampering in the first place. However, the potential payoff might be immense, pushing it to temporarily step over its drive towards morality in an episode of frenetic consequentialism.\"), mdx(\"p\", null, \"Other reactions to this concern might require additional technical tweaks. For instance, as the evaluation is reliably deterministic (as opposed to direct human feedback), it can run in multiple different sandbox environments, before various inter-annotator agreement schemes would be employed to pin down compromised hosts. Such partial compromise might trigger a killswitch (which itself might be faulty). However, this scheme is still vulnerable to situations in which Alex compromises all hosts at the same time, leaving out no evidence of lack of consensus and covering its tracks.\"), mdx(\"p\", null, \"Yet another reaction to this concern consists in rewarding the process of being rewarded via the original evaluation pipeline in particular. One of the terminal goals on which Alex would be conditioned could be to allow itself to be evaluated in the original fashion. This line of reasoning was inspired by Tammy. Perhaps it would be rewarded for helping the evaluator follow each step of its pipeline (e.g. each line of code, each machine code op, etc.). However, the same concern resurfaces. Alex might just swallow short-term penalties triggered by tampering in light of potentially huge consequentialist payoffs.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"189bf4b0-34a2-518f-b063-40bdd838861a","fields":{"slug":"/what-if-alex-hacks-the-deontic-array","title":"What if Alex hacks the deontic array?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if moral absolutism is misguided?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-moral-absolutism-is-misguided\"\n  }, \"What if moral absolutism is misguided?\"), mdx(\"p\", null, \"Deploying a deontic array assumes a seed charter containing a finite set of normative principles written down by a group of people. In this, the appriach contains moral absolutism as a design choice. This stance refers to the view that there is a specific normative framework which should ideally be projected on the world, rather than there being multiple valid frameworks which conflict with each other. Assuming for the sake of argument that deontic arrays work on a technical level in steering Alex away from taking over, is this what we actually want to project on the world?\"), mdx(\"p\", null, \"Perhaps future ethicists, after a few more millennia of progress, might reach a consensus on the fact that moral absolutism is deeply flawed in a fundamental way. This possibility is concerning, because the very architecture of deontic arrays relies on mostly locking down the seed normative framework, except for automated internal patching.\"), mdx(\"p\", null, \"A lazy reaction to this could be that we should first worry about avoiding the existential risks of the precipice before deliberating on deep questions of morality. We might have all the time in the world to worry about it some time later, and we've got more salient things to do.\"), mdx(\"p\", null, \"However, it might be difficult to impossible to tamper with a post-takeoff AGI in a meaningful way. Much of the appeal of deontic arrays relies on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" having humans in the loop in an attempt to reduce the attack surface. I suspect other proposals which include deferring to a past human (e.g. Vanessa Kosoy's fascinating preDCA) to run into similar issues.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"b6e38169-5e9f-5a39-8759-06cef0e2a477","fields":{"slug":"/what-if-moral-absolutism-is-misguided","title":"What if moral absolutism is misguided?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if immoral means are required for moral ends?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-immoral-means-are-required-for-moral-ends\"\n  }, \"What if immoral means are required for moral ends?\"), mdx(\"p\", null, \"In siblings of this node, I've touched on cases where immoral-but-appealing ends might compel Alex to acutely suppress its sense of morality. However, what if there are utopic ends which we actually want which at the same time require morally-ambiguous means to implement? Perhaps limiting one's freedom of movement is harsh, but leads to situation in which one's right to health is better respected.\"), mdx(\"p\", null, \"This is obviously a symptom of an age-old debate between deontology and consequentialism, including their variants blurring the dichotomy. If it turns out that we lack any reliable consequentialist safety mechanism, resorting to deontology-inspired mechanisms (e.g. this one) might be the consequentialist thing to do (because of not being overrun). Still, this line of reasoning hints at issues with the field of technical AGI safety as mostly disconnected from ethics. Alternatively, a deontology could also contain some narrow consequentialist principles.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"8340276c-6698-5ff2-84f5-72e0b5141755","fields":{"slug":"/what-if-immoral-means-are-required-for-moral-ends","title":"What if immoral means are required for moral ends?"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What if the two component rewards are unstable?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"what-if-the-two-component-rewards-are-unstable\"\n  }, \"What if the two component rewards are unstable?\"), mdx(\"p\", null, \"In its vanilla formulation, a deontic array is supposed to contribute part of the aggregate reward given to Alex, together with the main original reward associated with human feedback. Let's refer to those as human feedback (HF) reward, deontic reward, and aggregate reward (composed of the previous two). In this situation, what if Alex expects excellent human feedback from a course of action with poor deontic reward? What if HF reward trumps the deontic one, with large potential payoffs steering Alex away from morality?\"), mdx(\"p\", null, \"To tackle this situations, it might help to make either make both HF and deontic reward bounded or unbounded. If HF is unbounded while deontic is not, there's no question about what will end up driving Alex more. In the equality cases, they might be more comparable, with both bounded appearing safer.\"), mdx(\"p\", null, \"Besides individual bounds on reward sources, the aggregation scheme involved in computing the aggregate reward could penalize large differences between HF and deontic. If HF is huge but deontic is low, the aggregate could be much closer to deontic via e.g. a geometric mean. However, humans might themselves want to occasionally clash with the charter for various reasons. Such an aggregation scheme would naturally also limit their impact.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"e77d7409-9fe6-57a6-a8df-e167a82468bc","fields":{"slug":"/what-if-the-two-component-rewards-are-unstable","title":"What if the two component rewards are unstable?"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Deontic Arrays\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"deontic-arrays\"\n  }, \"Deontic Arrays\"), mdx(\"p\", null, \"What if we engineered discreteness into the objective function, while preserving the appeal of end-to-end differentiability? A finite set of discrete structures (e.g. attractors, repellers, dipoles, etc.) could be used to exert force on a model and influence its dynamics, a bit like DeepMind actively \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.deepmind.com/blog/accelerating-fusion-science-through-learned-plasma-control\"\n  }, \"shaping plasma\"), \" inside a fusion reactor using a set of magnets. In the case of deontic arrays, individual structures could be human principles, while the target shape would correspond to a region of state space deemed safe. The discreteness of deontology (i.e. finite sets of moral laws) lends itself nicely to various generalization schemes, such as cross-validation followed by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.deepmind.com/publications/red-teaming-language-models-with-language-models\"\n  }, \"targeted red teaming\"), \". Deontic arrays could also populate a host of different state spaces (e.g. latent space during inference, model space during training, optimizer space during meta-learning, etc.).\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment\",\n    \"title\": \"how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment\"\n  }, \"[[how-do-deontic-arrays-relate-to-concrete-challenges-in-alignment]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-could-deontic-arrays-help-avoid-hfdt-takeover\",\n    \"title\": \"how-could-deontic-arrays-help-avoid-hfdt-takeover\"\n  }, \"[[how-could-deontic-arrays-help-avoid-hfdt-takeover]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"ba9d0692-6b49-5964-a4b9-b6d7d4d0f455","fields":{"slug":"/deontic-arrays","title":"Deontic Arrays"}}}]},"fields":{"slug":"/how-could-deontic-arrays-help-avoid-hfdt-takeover","title":"How could deontic arrays help avoid HFDT takeover?"}}},"pageContext":{"id":"d00481bd-f8cb-5990-b827-e5f36400946a"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}